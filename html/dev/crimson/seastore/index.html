

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>SeaStore &mdash; Ceph Documentation</title>
  

  
  <link rel="stylesheet" href="../../../_static/ceph.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/ceph.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/graphviz.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/css/custom.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/sphinx_highlight.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../genindex/" />
    <link rel="search" title="Search" href="../../../search/" />
    <link rel="next" title="PoseidonStore" href="../poseidonstore/" />
    <link rel="prev" title="BackfillMachine" href="../backfillmachine/" /> 
</head>

<body class="wy-body-for-nav">

   
  <header class="top-bar">
    <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../internals/">Ceph 内幕</a></li>
          <li class="breadcrumb-item"><a href="../">Crimson developer documentation</a></li>
      <li class="breadcrumb-item active">SeaStore</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../_sources/dev/crimson/seastore.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
  </header>
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #eee" >
          

          
            <a href="../../../" class="icon icon-home"> Ceph
          

          
          </a>

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search/" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../../start/">Ceph 简介</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../install/">安装 Ceph</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../cephadm/">Cephadm</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../rados/">Ceph 存储集群</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../cephfs/">Ceph 文件系统</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../rbd/">Ceph 块设备</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../radosgw/">Ceph 对象网关</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../mgr/">Ceph 管理器守护进程</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../mgr/dashboard/">Ceph 仪表盘</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../monitoring/">监控概览</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/">API 文档</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../architecture/">体系结构</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developer_guide/">开发者指南</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../internals/">Ceph 内幕</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../../balancer-design/">Ceph 如何均衡（读写、容量）</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../blkin/">Tracing Ceph With LTTng</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../blkin/#tracing-ceph-with-blkin">Tracing Ceph With Blkin</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../bluestore/">BlueStore Internals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../ceph_krb_auth/">如何配置好 Ceph Kerberos 认证的详细文档</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../cephfs-fscrypt/">CephFS Fscrypt</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../cephfs-mirroring/">CephFS Mirroring</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../cephfs-reclaim/">CephFS Reclaim Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../cephfs-snapshots/">CephFS 快照</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../cephx/">Cephx</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../cephx_protocol/">Cephx 认证协议详细阐述</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../config/">配置管理系统</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../config-key/">config-key layout</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../context/">CephContext</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../continuous-integration/">Continuous Integration Architecture</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../corpus/">资料库结构</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../cpu-profiler/">Oprofile 的安装</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../cputrace/">CpuTrace</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../crush-msr/">CRUSH MSR (Multi-step Retry)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../cxx/">C++17 and libstdc++ ABI</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../deduplication/">去重</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../delayed-delete/">CephFS delayed deletion</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../dev_cluster_deployment/">开发集群的部署</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../dev_cluster_deployment/#id5">在同一机器上部署多套开发集群</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../development-workflow/">开发流程</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../documenting/">为 Ceph 写作文档</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../dpdk/">Ceph messenger DPDKStack</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../encoding/">序列化（编码、解码）</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../erasure-coded-pool/">纠删码存储池</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../file-striping/">File striping</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../freebsd/">FreeBSD Implementation details</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../generatedocs/">Ceph 文档的构建</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../health-reports/">Health Reports</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../iana/">IANA 号</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../kclient/">Testing changes to the Linux Kernel CephFS driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../kclient/#step-one-build-the-kernel">Step One: build the kernel</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../kclient/#step-two-create-a-vm">Step Two: create a VM</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../kclient/#step-three-networking-the-vm">Step Three: Networking the VM</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../kubernetes/">Hacking on Ceph in Kubernetes with Rook</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../libcephfs_proxy/">Design of the libcephfs proxy</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../libs/">库体系结构</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../logging/">集群日志的用法</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../logs/">调试日志</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../macos/">在 MacOS 上构建</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../mempool_accounting/">What is a mempool?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../mempool_accounting/#some-common-mempools-that-we-can-track">Some common mempools that we can track</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../messenger/">Messenger notes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../mon-bootstrap/">Monitor bootstrap</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../mon-elections/">Monitor Elections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../mon-on-disk-formats/">ON-DISK FORMAT</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../mon-osdmap-prune/">FULL OSDMAP VERSION PRUNING</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../msgr2/">msgr2 协议（ msgr2.0 和 msgr2.1 ）</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../network-encoding/">Network Encoding</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../network-protocol/">网络协议</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../object-store/">对象存储架构概述</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../osd-class-path/">OSD class path issues</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../peering/">互联</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../perf/">Using perf</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../perf_counters/">性能计数器</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../perf_histograms/">Perf histograms</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../placement-group/">PG （归置组）说明</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../pool-migration-design/">Design of Pool Migration</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../quick_guide/">开发者指南（快速）</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../rados-client-protocol/">RADOS 客户端协议</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../rbd-diff/">RBD 增量备份</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../rbd-export/">RBD Export &amp; Import</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../rbd-layering/">RBD Layering</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../release-checklists/">Release checklists</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../release-process/">Ceph Release Process</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../sepia/">Sepia 社区测试实验室</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../session_authentication/">Session Authentication for the Cephx Protocol</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../testing/">测试笔记</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../versions/">Public OSD Version</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../vstart-ganesha/">NFS CephFS-RGW Developer Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../wireshark/">Wireshark Dissector</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../zoned-storage/">Zoned Storage Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../osd_internals/">OSD 开发者文档</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../mds_internals/">MDS 开发者文档</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../radosgw/">RADOS 网关开发者文档</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../ceph-volume/">ceph-volume 开发者文档</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../">Crimson developer documentation</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../#building-crimson">Building Crimson</a></li>
<li class="toctree-l3"><a class="reference internal" href="../#vstart-sh">vstart.sh</a></li>
<li class="toctree-l3"><a class="reference internal" href="../#profiling-crimson">Profiling Crimson</a></li>
<li class="toctree-l3"><a class="reference internal" href="../#hacking-crimson">Hacking Crimson</a></li>
<li class="toctree-l3"><a class="reference internal" href="../#debugging-crimson">Debugging Crimson</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="../#code-walkthroughs">Code Walkthroughs</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="../osd/">OSDState</a></li>
<li class="toctree-l4"><a class="reference internal" href="../pipeline/">The ClientRequest Pipeline</a></li>
<li class="toctree-l4"><a class="reference internal" href="../error-handling/">Error Handling</a></li>
<li class="toctree-l4"><a class="reference internal" href="../backfillmachine/">BackfillMachine</a></li>
<li class="toctree-l4 current"><a class="current reference internal" href="#">SeaStore</a></li>
<li class="toctree-l4"><a class="reference internal" href="../poseidonstore/">PoseidonStore</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../governance/">项目管理</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../foundation/">Ceph 基金会</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../ceph-volume/">ceph-volume</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../crimson/crimson/">Crimson (Tech Preview)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../releases/general/">Ceph 版本（总目录）</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../releases/">Ceph 版本（索引）</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../security/">Security</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../hardware-monitoring/">硬件监控</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../glossary/">Ceph 术语</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../jaegertracing/">Tracing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../translation_cn/">中文版翻译资源</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../">Ceph</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
<div id="dev-warning" class="admonition note">
  <p class="first admonition-title">Notice</p>
  <p class="last">This document is for a development version of Ceph.</p>
</div>
  <div id="docubetter" align="right" style="padding: 5px; font-weight: bold;">
    <a href="https://pad.ceph.com/p/Report_Documentation_Bugs">Report a Documentation Bug</a>
  </div>

  
  <section id="seastore">
<span id="id1"></span><h1>SeaStore<a class="headerlink" href="#seastore" title="Permalink to this heading"></a></h1>
<section id="goals-and-basics">
<h2>Goals and Basics<a class="headerlink" href="#goals-and-basics" title="Permalink to this heading"></a></h2>
<ul class="simple">
<li><p>Target NVMe devices primarily, with interest in HDDs as well.</p></li>
<li><p>make use of SPDK for user-space driven IO</p></li>
<li><p>Use Seastar futures programming model to facilitate
run-to-completion and a sharded memory/processing model</p></li>
<li><p>Allow zero (or minimal) data copying on read and write paths when
combined with a Seastar-based messenger using DPDK</p></li>
</ul>
<section id="data-layout-basics">
<h3>Data layout basics<a class="headerlink" href="#data-layout-basics" title="Permalink to this heading"></a></h3>
<p>One or more cores/shards will be reading and writing to the device at
once.  Each shard will have its own independent data it is operating
on and stream to its own open segments.  Devices that support streams
can be hinted accordingly so that data from different shards is not
mixed on the underlying media.</p>
</section>
</section>
<section id="architecture">
<h2>Architecture<a class="headerlink" href="#architecture" title="Permalink to this heading"></a></h2>
<img alt="../../../_images/seastore_arch.svg" src="../../../_images/seastore_arch.svg" /></section>
<section id="design">
<h2>Design<a class="headerlink" href="#design" title="Permalink to this heading"></a></h2>
<p>Each reactor manages its own root.  Prior to reusing a segment, we rewrite any live
blocks to an open segment.</p>
<p>Because we are only writing sequentially to open segments, we must
“clean” one byte of an existing segment for every byte written at
steady state.  Generally, we’ll need to reserve some portion of the
usable capacity in order to ensure that write amplification remains
acceptably low (20% for 2x? -- TODO: find prior work). We support both
background garbage collection, which allows us to exploit periods of
lower I/O demand, and inline relocation of blocks from existing
segments as part of ongoing client I/O.</p>
<section id="metadata-structures">
<span id="id2"></span><h3>Metadata Structures<a class="headerlink" href="#metadata-structures" title="Permalink to this heading"></a></h3>
<img alt="../../../_images/seastore.svg" src="../../../_images/seastore.svg" /><p><strong>Extents</strong>:</p>
<blockquote>
<div><p>An extent is an allocation unit on disk. All extents are either <strong>physically addressed</strong> (<code class="docutils literal notranslate"><span class="pre">paddr_t</span></code>)
(direct physical location on disk) or <strong>logically addressed</strong> (<code class="docutils literal notranslate"><span class="pre">laddr_t</span></code>).
Logically addressed extents are referred to by logical rather than physical addresses, allowing them to
be relocated freely without affecting the data structures they belong to.
The vast majority of extents fall into this category.</p>
<p>There are multiple types of extents, such as <code class="docutils literal notranslate"><span class="pre">ROOT</span></code>, <code class="docutils literal notranslate"><span class="pre">OMAP_LEAF</span></code>, and <code class="docutils literal notranslate"><span class="pre">OBJECT_DATA_BLOCK</span></code>
(see <code class="docutils literal notranslate"><span class="pre">extent_types_t</span></code> for the full list).
Each extent type can interpret <strong>journal deltas</strong> differently, see <a class="reference internal" href="#journal"><span class="std std-ref">Journal</span></a> for details.</p>
<p><em>Interface:</em> <code class="docutils literal notranslate"><span class="pre">ObjectDataHandler</span></code></p>
</div></blockquote>
<dl>
<dt><strong>Onode Tree</strong>:</dt><dd><p>Maps <code class="docutils literal notranslate"><span class="pre">ghobject_t</span></code> to <code class="docutils literal notranslate"><span class="pre">Onode</span></code>. The Onode layout (<code class="docutils literal notranslate"><span class="pre">onode_layout_t</span></code>) will consist the
Omap Btrees and the <code class="docutils literal notranslate"><span class="pre">extent_types_t::OBJECT_DATA_BLOCK</span></code> extents.</p>
<p><em>Interface:</em> <code class="docutils literal notranslate"><span class="pre">FLTreeOnodeManager</span></code></p>
</dd>
<dt><strong>Omap Btree</strong>:</dt><dd><p>Stores <code class="docutils literal notranslate"><span class="pre">omap_type_t</span></code> entries for each object.</p>
<p><em>Interface:</em> <code class="docutils literal notranslate"><span class="pre">BtreeOMapManager</span></code></p>
<p>The same <code class="docutils literal notranslate"><span class="pre">BtreeOMapManager</span></code> interface is used for handling multiple omap types:</p>
<p><code class="docutils literal notranslate"><span class="pre">omap_type_t::OMAP</span></code>, <code class="docutils literal notranslate"><span class="pre">omap_type_t::XATTRS</span></code>, and <code class="docutils literal notranslate"><span class="pre">omap_type_t::LOG</span></code>.</p>
<p>Each type is stored in its own tree, but the interface remains consistent to avoid reimplementation for each type.</p>
</dd>
<dt><strong>LBA Btree</strong>:</dt><dd><p>Mappings of a logically addressed extents to either a physical address or
another (indirect) logical address.</p>
<p><em>Mapping:</em> <code class="docutils literal notranslate"><span class="pre">laddr_t</span></code> --&gt; <code class="docutils literal notranslate"><span class="pre">pladdr_t</span></code></p>
<p><em>Extents:</em> <code class="docutils literal notranslate"><span class="pre">LADDR_INTERNAL</span></code> and <code class="docutils literal notranslate"><span class="pre">LADDR_LEAF</span></code></p>
<p><em>Interface:</em> <code class="docutils literal notranslate"><span class="pre">LBAManager</span></code></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">pladdr_t</span></code> represents either <code class="docutils literal notranslate"><span class="pre">paddr_t</span></code> (direct mapping) or <code class="docutils literal notranslate"><span class="pre">laddr_t</span></code> (indirect mapping).
See <a class="reference internal" href="#lbamanager"><span class="std std-ref">LBAManager/BtreeLBAManager</span></a>.</p>
</div>
<dl>
<dt><strong>Backref Tree</strong>:</dt><dd><p>Maps physically addressed extents to logical addresses.</p>
<p><em>Mapping:</em> <code class="docutils literal notranslate"><span class="pre">paddr_t</span></code> --&gt; <code class="docutils literal notranslate"><span class="pre">laddr_t</span></code></p>
<p><em>Extents:</em> <code class="docutils literal notranslate"><span class="pre">BACKREF_INTERNAL</span></code> and <code class="docutils literal notranslate"><span class="pre">BACKREF_LEAF</span></code></p>
<p><em>Interface:</em> <code class="docutils literal notranslate"><span class="pre">BackrefManager</span></code></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The Backref Tree is used only for <strong>garbage collection</strong> on <strong>Segmented Seastore device types</strong>
(See SegmmentCleaner).</p>
</div>
</section>
<section id="device-types">
<span id="id3"></span><h3>Device Types<a class="headerlink" href="#device-types" title="Permalink to this heading"></a></h3>
<p>Configured via the <code class="docutils literal notranslate"><span class="pre">seastore_main_device_type</span></code> option, the device types are
separated into <strong>Segmented</strong> and <strong>RBM</strong> backend types as follows:</p>
<ul>
<li><p><strong>backend_type_t::SEGMENTED</strong>:</p>
<p><strong>Segmented Backend Motivation:</strong>:</p>
<p>All flash devices are internally structured in terms of erasure blocks that
can be written efficiently but must be erased in their entirety. The
NVMe device generally has limited knowledge about what data in a
segment is still “live” (hasn’t been logically discarded). This limited
knowledge reduces garbage-collection efficiency when data with mixed lifetimes
shares the same segments. We can design an on-device layout that is friendly to GC at lower layers and
drive garbage collection at higher layers.</p>
<p>The basic idea is that all data will be stream out sequentially to
large segments on the device.  In the SSD hardware, segments are
likely to be on the order of hundreds of MB to tens of GB.</p>
<p>SeaStore’s logical segments would ideally be perfectly aligned with
the hardware segments.  In practice, it may be challenging to
determine geometry and to sufficiently hint to the device that LBAs
being written should be aligned to the underlying hardware.
In the worst case, we can structure our logical segments to span multiple physical segments sizes,
to avoid the metadata cost of representing each erasure block independently.</p>
<p>When we reach some utilization threshold, we mix cleaning work in with
the ongoing write workload in order to evacuate live data from
previously written segments.  Once they are completely free we can
discard the entire segment so that it can be erased and reclaimed by
the device.</p>
<p>The key is to mix a small bit of cleaning work with every write
transaction to avoid spikes and variance in write latency.</p>
<p><strong>Segment Layout:</strong>:</p>
<p>The backing storage is abstracted into a set of segments.</p>
<p>The types of segements are:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">segment_type_t::JOURNAL</span></code> - See Journal Types in <a class="reference internal" href="#journal"><span class="std std-ref">Journal</span></a></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">segment_type_t::OOL</span></code> - Data segments</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">segment_type_t::NULL_SEG</span></code> - Initial segment state</p></li>
</ul>
<p>Each segment can be in one of Three states:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">segment_state_t::EMPTY</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">segment_state_t::OPEN</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">segment_state_t::CLOSED</span></code>.</p></li>
</ul>
<p>Each segment is prefixed with <code class="docutils literal notranslate"><span class="pre">segment_header_t</span></code> in the first block and suffixed with a <code class="docutils literal notranslate"><span class="pre">segment_tail_t</span></code>.</p>
<p>Note that segments will generally be large (something like &gt;=256MB),
so there will not typically be very many of them.</p>
<p>Each shard will keep open N segments for writes</p>
<ul class="simple">
<li><p>HDD: N is probably 1 on one shard</p></li>
<li><p>NVME/SSD: N is probably 2/shard, one for “journal” and one for
finished data records as their lifetimes are different.</p></li>
</ul>
<p>I think the exact number to keep open and how to partition writes
among them will be a tuning question -- GC/layout should be flexible.
Where practical, the goal is to partition blocks by expected
lifetime so that a segment either has long lived or short lived
blocks.</p>
<p>Segment: [ <code class="docutils literal notranslate"><span class="pre">segment_header_t</span></code> | <code class="docutils literal notranslate"><span class="pre">record_t</span></code> | <code class="docutils literal notranslate"><span class="pre">record_t</span></code> | <code class="docutils literal notranslate"><span class="pre">record_t</span></code> … ]</p>
<p>Used for:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">device_type_t::SSD</span></code> (default)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">device_type_t::HDD</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">device_type_t::ZBD</span></code></p></li>
</ul>
<p>Preferred for sequential writes. Can’t overwrite written extents (similar to ZNS).</p>
<p><em>Interface:</em> <code class="docutils literal notranslate"><span class="pre">SegmentManager</span></code></p>
</li>
<li><p><strong>backend_type_t::RANDOM_BLOCK</strong>:</p>
<p>Used for:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">device_type_t::RANDOM_BLOCK_SSD</span></code></p></li>
</ul>
<p>Preferred for fast NVMe devices where overwrites are efficient enough
that log structured updates aren’t worth the overhead.</p>
<p><em>Interface:</em> <code class="docutils literal notranslate"><span class="pre">RBMDevice</span></code></p>
</li>
</ul>
</section>
<section id="journal">
<span id="id4"></span><h3>Journal<a class="headerlink" href="#journal" title="Permalink to this heading"></a></h3>
<p><em>Interface:</em> <code class="docutils literal notranslate"><span class="pre">Journal</span></code></p>
<p>See <code class="docutils literal notranslate"><span class="pre">src/crimson/os/seastore/journal.h</span></code></p>
<p>Responsible for atomically writing (<code class="docutils literal notranslate"><span class="pre">Journal::submit_record</span></code>) and replaying
(<code class="docutils literal notranslate"><span class="pre">Journal::reply</span></code>) journal records. A journal record <code class="docutils literal notranslate"><span class="pre">record_t</span></code> is a struct containing deltas and extents.</p>
<p><strong>Journal Records</strong>:</p>
<p>The byte contents of segments are a sequence of <code class="docutils literal notranslate"><span class="pre">record_t</span></code> records.
A group of records is prefixed by a <code class="docutils literal notranslate"><span class="pre">record_group_header_t</span></code> header which includes the number of records,
length of the data and checksum. A record group is a set of records that are written to disk in a single write operation.</p>
<p>See <code class="docutils literal notranslate"><span class="pre">RecordSubmitter::flush_current_batch()</span></code>.</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">record_type_t::OOL</span></code>:</p>
<p>Data records. These records are not padded and do not contain <strong>any</strong> metadata (See <code class="docutils literal notranslate"><span class="pre">encode_records</span></code>).</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">record_type_t::JOURNAL</span></code>:</p>
<p>Used in the Journal segment only.
Each record is then prefixed by <code class="docutils literal notranslate"><span class="pre">record_header_t</span></code> which contain the number of deltas and extents sequence in this record.</p>
<p>Each delta (<code class="docutils literal notranslate"><span class="pre">delta_info_t</span></code>) describes a logical mutation for some block.
Each included block is an aligned extent addressable by <code class="docutils literal notranslate"><span class="pre">&lt;segment_id_t,</span> <span class="pre">segment_off_t&gt;</span></code>.
A transaction can be implemented by constructing a record combining deltas and updated blocks and writing
it to an open segment.</p>
</li>
</ul>
<p>Record: [ <code class="docutils literal notranslate"><span class="pre">record_header_t</span></code> | <code class="docutils literal notranslate"><span class="pre">record_type_t::delta</span></code> | <code class="docutils literal notranslate"><span class="pre">record_type_t::delta</span></code>… | <code class="docutils literal notranslate"><span class="pre">record_type_t::extents</span></code> | <code class="docutils literal notranslate"><span class="pre">record_type_t::extents</span></code> … ]</p>
<p>See <code class="docutils literal notranslate"><span class="pre">src/crimson/os/seastore/seastore_types.h</span></code> for most SeaStore structures.</p>
<p><strong>Journal Trimming</strong>:</p>
<p>The journal trimming interface is <code class="docutils literal notranslate"><span class="pre">JournalTrimmer</span></code> and is implemented in <code class="docutils literal notranslate"><span class="pre">JournalTrimmerImpl</span></code>.
Periodically, we trim the journal (else, we’d have to replay
journal deltas from the beginning of time). Journal entries can be trimmed once the
extents they reference have been rewritten elsewhere (See: <code class="docutils literal notranslate"><span class="pre">JournalTrimmerImpl::trim_dirty()</span></code>).</p>
<p><strong>Journal Deltas</strong>:</p>
<p>Deltas are logical mutations to existing extents.
Note, deltas are not always byte range modifications.  Consider a btree
node structured with keys to the left and values to the right (common
trick for improving point query/key scan performance).  Inserting a
key/value into that node at the min would involve moving a bunch of
bytes, which would be expensive (or verbose) to express purely as a
sequence of byte operations.  As such, each delta indicates the type
as well as the location of the corresponding extent.  Each block
type can therefore implement <code class="docutils literal notranslate"><span class="pre">CachedExtent::apply_delta</span></code> as appropriate.
For example, <code class="docutils literal notranslate"><span class="pre">OMapInnerNode::apply_delta</span></code> or <code class="docutils literal notranslate"><span class="pre">ObjectDataBlock::apply_delta</span></code>.</p>
<p>A transaction is represented by an atomically written record.
Transaction deltas are always written to the journal.  If the transaction is associated
with blocks written to other segments, final record with the deltas
should be written only once the other blocks are persisted.  Crash
recovery is done by finding the segment containing the beginning of
the current journal, loading the root node, replaying the deltas, and
loading blocks into the cache as needed.</p>
<p><strong>Journal Types</strong>:</p>
<p>According to the <a class="reference internal" href="#device-types"><span class="std std-ref">Device Types</span></a>, the journal has two implementations:</p>
<ul>
<li><p><strong>SegmentedJournal</strong>: Used for Segmented devices.</p>
<ul class="simple">
<li><p>One open segment is designated as the journal (<code class="docutils literal notranslate"><span class="pre">segment_type_t::JOURNAL</span></code>).</p></li>
<li><p>The size of the journal segment is equal to <code class="docutils literal notranslate"><span class="pre">seastore_segment_size</span></code>.</p></li>
<li><p>A record can contain:</p></li>
</ul>
<blockquote>
<div><ul class="simple">
<li><p>Blocks written as part of the transaction (inline)</p></li>
<li><p>Journal deltas</p></li>
</ul>
</div></blockquote>
<ul class="simple">
<li><p>Small or short-lived extents (e.g., leaf nodes) can be written inline to the journal segment.
This is possible when the delta fits in the journal record and when the extent is expected
to be updated again soon. Longer-lived or large extents are written to out-of-line segments
(<code class="docutils literal notranslate"><span class="pre">segment_type_t::OOL</span></code>). Writing out-of-line extents avoids unnecessary
data movement during segment cleaning.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">record_type_t::OOL</span></code> will never contain metadata. See <code class="docutils literal notranslate"><span class="pre">record_size_t::get_raw_mdlength()</span></code> for example.</p></li>
</ul>
</li>
<li><p><strong>CircularBoundedJournal</strong>: Used for RBM devices.</p>
<ul class="simple">
<li><p>Journal is fixed size (configured via <code class="docutils literal notranslate"><span class="pre">seastore_cbjournal_size</span></code>)</p></li>
<li><p>A record will contain <strong>only</strong> Journal deltas as all extents are written out-of-line, outside the journal.</p></li>
<li><p>Trimming the journal does not require moving data since no data is written inline.</p></li>
</ul>
</li>
</ul>
</section>
<section id="block-cache">
<h3>Block Cache<a class="headerlink" href="#block-cache" title="Permalink to this heading"></a></h3>
<p>Every block is in one of the following states:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">extent_state_t::INITIAL_WRITE_PENDING</span></code>:</p>
<p>In <code class="docutils literal notranslate"><span class="pre">Transaction::write_set</span></code> and <code class="docutils literal notranslate"><span class="pre">fresh_block_list</span></code>; has <code class="docutils literal notranslate"><span class="pre">prior_instance</span></code> under rewrite.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">extent_state_t::MUTATION_PENDING</span></code>:</p>
<p>In <code class="docutils literal notranslate"><span class="pre">Transaction::write_set</span></code> and <code class="docutils literal notranslate"><span class="pre">mutated_block_list</span></code>; has <code class="docutils literal notranslate"><span class="pre">prior_instance</span></code>.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">extent_state_t::CLEAN</span></code>:</p>
<p>In <code class="docutils literal notranslate"><span class="pre">Cache::extent_index</span></code> and in <code class="docutils literal notranslate"><span class="pre">Transaction::read_set</span></code> during write.
Contents match disk; <code class="docutils literal notranslate"><span class="pre">version</span> <span class="pre">==</span> <span class="pre">0</span></code>.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">extent_state_t::DIRTY</span></code>:</p>
<p>Must be fully present in the cache. Contents do not match disk; <code class="docutils literal notranslate"><span class="pre">version</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>.
The current version of the record requires overlaying deltas from the journal.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">extent_state_t::EXIST_CLEAN</span></code>:</p>
<p>Similar to <code class="docutils literal notranslate"><span class="pre">CLEAN</span></code>, but its metadata has not yet been persisted to disk.
Present in <code class="docutils literal notranslate"><span class="pre">Transaction::write_set</span></code> and <code class="docutils literal notranslate"><span class="pre">existing_block_list</span></code>.
After the transaction commits, the state becomes <code class="docutils literal notranslate"><span class="pre">CLEAN</span></code> and the extent is added to the Cache.
Modifying such extents will transition the state to <code class="docutils literal notranslate"><span class="pre">EXIST_MUTATION_PENDING</span></code>.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">extent_state_t::EXIST_MUTATION_PENDING</span></code>:</p>
<p>Similar to <code class="docutils literal notranslate"><span class="pre">MUTATION_PENDING</span></code>, but <code class="docutils literal notranslate"><span class="pre">prior_instance</span></code> is empty.
Present in <code class="docutils literal notranslate"><span class="pre">Transaction::write_set</span></code>, <code class="docutils literal notranslate"><span class="pre">existing_block_list</span></code>, and <code class="docutils literal notranslate"><span class="pre">mutated_block_list</span></code>.
After the transaction commits, the state becomes <code class="docutils literal notranslate"><span class="pre">DIRTY</span></code> and the extent is added to the Cache.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">extent_state_t::INVALID</span></code>:</p>
<p>No <code class="docutils literal notranslate"><span class="pre">ExtentIndex</span></code> set.</p>
</li>
</ul>
<p>SeaStore uses caching not only for performance but also for <strong>correctness</strong> purposes.</p>
<p>The cache can represent the <em>projected</em> outcome of to-be-committed transactions.
This projected state can be used during reads (<code class="docutils literal notranslate"><span class="pre">TransactionManager::read_pin</span></code>) to verify checksums.
It ensures that persisted extent checksum matches the projected transaction outcome when handling
a fully loaded extent during reads. For testing purposes, we can also force a full re-load on reads
(see <code class="docutils literal notranslate"><span class="pre">Cache::check_full_extent_integrity</span></code>).</p>
<p>Caching also keeps <code class="docutils literal notranslate"><span class="pre">extent_state_t::DIRTY</span></code> extents, those whose contents differ
from what is persisted, <strong>pinned in memory</strong>. Pinning is managed through the
<code class="docutils literal notranslate"><span class="pre">ExtentPinboard</span></code> interface, which supports two caching algorithms: <strong>LRU</strong> and
<strong>2Q</strong> (configured via <code class="docutils literal notranslate"><span class="pre">seastore_cachepin_type</span></code>).</p>
<p>The caching layer additionally detects <strong>transaction conflicts</strong> that require
retries (see <code class="docutils literal notranslate"><span class="pre">Cache::mark_transaction_conflicted</span></code>). However, this mechanism is
planned to be removed due to high retry rate write workloads.</p>
<p><strong>Interface:</strong> <code class="docutils literal notranslate"><span class="pre">Cache</span></code></p>
<p>See: <code class="docutils literal notranslate"><span class="pre">src/crimson/os/seastore/cache.h</span></code></p>
<p>See src/os/crimson/seastore/cached_extent.h.
See src/os/crimson/seastore/cache.h.</p>
</section>
<section id="gc">
<h3>GC<a class="headerlink" href="#gc" title="Permalink to this heading"></a></h3>
<p>Prior to reusing a segment, we must relocate all live blocks.  Because
we only write sequentially to empty segments, for every byte we write
to currently open segments, we need to clean a byte of an existing
closed segment.  As a design choice, we’d like to avoid background
work as it complicates estimating operation cost and has a tendency to
create non-deterministic latency spikes.  Thus, under normal operation
each seastore reactor will be inserting enough work to clean a segment
at the same rate as incoming operations.</p>
<p>In order to make this cheap for sparse segments, we need a way to
positively identify dead blocks.  Thus, for every block written, an
entry will be added to the lba tree with a pointer to the previous lba
in the segment.  Any transaction that moves a block or modifies the
reference set of an existing one will include deltas/blocks required
to update the lba tree to update or remove the previous block
allocation.  The gc state thus simply needs to maintain an iterator
(of a sort) into the lba tree segment linked list for segment
currently being cleaned and a pointer to the next record to be
examined -- records not present in the allocation tree may still
contain roots (like allocation tree blocks) and so the record metadata
must be checked for a flag indicating root blocks.</p>
<p>For each transaction, we evaluate a heuristic function of the
currently available space and currently live space in order to
determine whether we need to do cleaning work (could be simply a range
of live/used space ratios).</p>
</section>
</section>
<section id="logical-layout">
<h2>Logical Layout<a class="headerlink" href="#logical-layout" title="Permalink to this heading"></a></h2>
<p>The above block and delta semantics are used to build the root level trees
described here <a class="reference internal" href="#metadata-structures"><span class="std std-ref">Metadata Structures</span></a>.</p>
<p>Each of the above structures is comprised of blocks with mutations
encoded in deltas.  Each node of the above trees maps onto an extent.
Each extent is either physically addressed (root blocks and the
lba_tree nodes) or is logically-addressed (everything else).
Physically addressed extents are located by a <code class="docutils literal notranslate"><span class="pre">paddr_t:</span> <span class="pre">&lt;segment_id_t,</span>
<span class="pre">segment_off_t&gt;</span></code> tuple and are marked as physically addressed in the
record. logically-addressed are addressed by <code class="docutils literal notranslate"><span class="pre">laddr_t</span></code> and require a lookup in
the lba_tree to address.</p>
<p>Because the cache/transaction machinery lives below the level of the
lba tree, we can represent atomic mutations of the lba tree and other
structures by simply including both in a transaction.</p>
<section id="lbamanager-btreelbamanager">
<span id="lbamanager"></span><h3>LBAManager/BtreeLBAManager<a class="headerlink" href="#lbamanager-btreelbamanager" title="Permalink to this heading"></a></h3>
<p>Implementations of the LBAManager interface are responsible for managing
the logical to physical mapping.</p>
<p>See: crimson/os/seastore/lba_manager.h</p>
<p>The BtreeLBAManager implements this interface directly on top of
Journal and SegmentManager using a wandering btree approach.</p>
<p>Because SegmentManager does not let us predict the location of a
committed record (a property of both SMR and Zone devices), references
to blocks created within the same transaction will necessarily be
<em>relative</em> addresses.  The BtreeLBAManager maintains an invariant by
which the in-memory copy of any block will contain only absolute
addresses when !is_pending() -- on_commit and complete_load fill in
absolute addresses based on the actual block addr and on_delta_write
does so based on the just committed record.  When is_pending(), if
is_initial_pending references in memory are block_relative (because
they will be written to the original block location) and
record_relative otherwise (value will be written to delta).</p>
<p>To support cloning, there are two kinds of LBA Mappings:</p>
<ul class="simple">
<li><p>Direct LBA Mapping: the <code class="docutils literal notranslate"><span class="pre">pladdr_t</span></code> in the value of is the <code class="docutils literal notranslate"><span class="pre">paddr_t</span></code> of the corresponding extent.</p></li>
<li><p>Indirect LBA Mapping: the <code class="docutils literal notranslate"><span class="pre">pladdr_t</span></code> in the value is an <code class="docutils literal notranslate"><span class="pre">laddr_t</span></code> pointing
to the direct LBA mapping that’s pointing to the actual paddr of the extent being searched.</p></li>
</ul>
</section>
<section id="transactionmanager">
<span id="id5"></span><h3>TransactionManager<a class="headerlink" href="#transactionmanager" title="Permalink to this heading"></a></h3>
<p>The TransactionManager is responsible for presenting a unified
interface on top of the Journal, SegmentManager, Cache, and
LBAManager.  Users can allocate and mutate extents based on logical
addresses with segment cleaning handled in the background.</p>
<p>See <code class="docutils literal notranslate"><span class="pre">crimson/os/seastore/transaction_manager.h</span></code></p>
</section>
<section id="extentplacementmanager">
<span id="id6"></span><h3>ExtentPlacementManager<a class="headerlink" href="#extentplacementmanager" title="Permalink to this heading"></a></h3>
<p>Manages extents across backing devices, allowing SeaStore to work with multiple,
potentially heterogeneous devices of potentially different performance classes.</p>
<p>See: <code class="docutils literal notranslate"><span class="pre">crimson/os/seastore/extent_placement_manager.h</span></code></p>
<p>ExtentPlacementManager is responsible for:</p>
<dl>
<dt><strong>Placing extents</strong>:</dt><dd><p>The extent is placed on a segment based on several factors, such as:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">data_category_t</span></code>: either <code class="docutils literal notranslate"><span class="pre">data_category_t::DATA</span></code> or <code class="docutils literal notranslate"><span class="pre">data_category_t::METADATA</span></code>.</p></li>
<li><p><cite>placement_hint_t</cite>: whether a mutation or retirement is expected, the options are
<code class="docutils literal notranslate"><span class="pre">placement_hint_t::HOT</span></code> and <code class="docutils literal notranslate"><span class="pre">placement_hint_t::COLD</span></code>. <code class="docutils literal notranslate"><span class="pre">placement_hint_t::REWRITE</span></code>
is used after ExtentPlacementManager (EPM) decisions for internal rewrites.</p></li>
</ul>
</dd>
<dt><strong>Background processes</strong>:</dt><dd><p>See <code class="docutils literal notranslate"><span class="pre">ExtentPlacementManager::BackgroundProcess::do_background_cycle()</span></code>.</p>
<p><em>Interface:</em> <code class="docutils literal notranslate"><span class="pre">AsyncCleaner</span></code> which holds the <code class="docutils literal notranslate"><span class="pre">background_callback</span></code>.</p>
<p>There are two implementations of the <code class="docutils literal notranslate"><span class="pre">AsyncCleaner</span></code> interface.
According to the <a class="reference internal" href="#device-types"><span class="std std-ref">Device Types</span></a>, these are <strong>RBMCleaner</strong> and <strong>SegmentCleaner</strong>.</p>
<ul class="simple">
<li><p><strong>SegmentCleaner</strong>: For Segmented devices, performs garbage collection on the segemets
on that device (See <cite>SegmentCleaner::clean_space()</cite>). Logical extents are remapped within the <a class="reference internal" href="#lbamanager"><span class="std std-ref">LBAManager/BtreeLBAManager</span></a>
and physical extents are updated accordingly. The SegmmentCleaner is also responisble for throttling GC work
in order to avoid abrupt pauses and maintain smooth IO latenices.</p></li>
</ul>
</dd>
</dl>
<p><strong>Tiering</strong>:</p>
<blockquote>
<div><div class="admonition note">
<p class="admonition-title">Note</p>
<p>Tiering is supported only for Segmented devices, using a dedicated cold
<code class="docutils literal notranslate"><span class="pre">SegmentCleaner</span></code>. All RBM extents belong to the <strong>same</strong> static generation
(<code class="docutils literal notranslate"><span class="pre">rewrite_gen_t::OOL</span></code>) and are never adjusted.</p>
</div>
<p>When multiple devices are present, the EPM considers how long ago an extent was
written. Extents that are rarely written or read may be demoted to a cold tier.
This logic is implemented by <code class="docutils literal notranslate"><span class="pre">rewrite_gen_t</span></code> which is designed to group the similar
aged extents in the same segment (See <code class="docutils literal notranslate"><span class="pre">adjust_generation</span></code>).</p>
<p>The number of tiers is set based on the configured <code class="docutils literal notranslate"><span class="pre">seastore_hot_tier_generations</span></code> and <code class="docutils literal notranslate"><span class="pre">seastore_cold_tier_generations</span></code>.
Each genreation maps its own segment and has its own dedicated <code class="docutils literal notranslate"><span class="pre">ExtentOolWriter</span></code> writer (See <code class="docutils literal notranslate"><span class="pre">generation_to_writer</span></code>).</p>
</div></blockquote>
</section>
</section>
<section id="next-steps">
<h2>Next Steps<a class="headerlink" href="#next-steps" title="Permalink to this heading"></a></h2>
<section id="cache">
<h3>Cache<a class="headerlink" href="#cache" title="Permalink to this heading"></a></h3>
<ul class="simple">
<li><p>Support for rewriting dirty blocks</p>
<ul>
<li><p>Need to add support to CachedExtent for finding/updating
dependent blocks</p></li>
<li><p>Need to add support for adding dirty block writout to
try_construct_record</p></li>
</ul>
</li>
</ul>
</section>
<section id="id7">
<h3>LBAManager<a class="headerlink" href="#id7" title="Permalink to this heading"></a></h3>
<ul class="simple">
<li><p>Add segment -&gt; laddr for use in GC</p></li>
<li><p>Support for locating remaining used blocks in segments</p></li>
</ul>
</section>
<section id="id8">
<h3>GC<a class="headerlink" href="#id8" title="Permalink to this heading"></a></h3>
<ul class="simple">
<li><p>Support in BtreeLBAManager for tracking used blocks in segments</p></li>
<li><p>Heuristic for identifying segments to clean</p></li>
</ul>
</section>
<section id="other">
<h3>Other<a class="headerlink" href="#other" title="Permalink to this heading"></a></h3>
<ul class="simple">
<li><p>Add support for periodically generating a journal checkpoint.</p></li>
</ul>
</section>
</section>
<section id="objectstore-considerations">
<h2>ObjectStore considerations<a class="headerlink" href="#objectstore-considerations" title="Permalink to this heading"></a></h2>
<section id="splits-merges-and-sharding">
<h3>Splits, merges, and sharding<a class="headerlink" href="#splits-merges-and-sharding" title="Permalink to this heading"></a></h3>
<p>One of the current ObjectStore requirements is to be able to split a
collection (PG) in O(1) time.  Starting in mimic, we also need to be
able to merge two collections into one (i.e., exactly the reverse of a
split).</p>
<p>However, the PGs that we split into would hash to different shards of
the OSD in the current sharding scheme.  One can imagine replacing
that sharding scheme with a temporary mapping directing the smaller
child PG to the right shard since we generally then migrate that PG to
another OSD anyway, but this wouldn’t help us in the merge case where
the constituent pieces may start out on different shards and
ultimately need to be handled in the same collection (and be operated
on via single transactions).</p>
<p>This suggests that we likely need a way for data written via one shard
to “switch ownership” and later be read and managed by a different
shard.</p>
</section>
</section>
</section>



<div id="support-the-ceph-foundation" class="admonition note">
  <p class="first admonition-title">Brought to you by the Ceph Foundation</p>
  <p class="last">The Ceph Documentation is a community resource funded and hosted by the non-profit <a href="https://ceph.io/en/foundation/">Ceph Foundation</a>. If you would like to support this and our other efforts, please consider <a href="https://ceph.io/en/foundation/join/">joining now</a>.</p>
</div>


           </div>
           
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="../backfillmachine/" class="btn btn-neutral float-left" title="BackfillMachine" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="../poseidonstore/" class="btn btn-neutral float-right" title="PoseidonStore" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2016, Ceph authors and contributors. Licensed under Creative Commons Attribution Share Alike 3.0 (CC-BY-SA-3.0).</p>
  </div>

   

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>