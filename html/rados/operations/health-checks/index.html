

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>健康检查 &mdash; Ceph Documentation</title>
  

  
  <link rel="stylesheet" href="../../../_static/ceph.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/ceph.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/graphviz.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/css/custom.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/sphinx_highlight.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../genindex/" />
    <link rel="search" title="Search" href="../../../search/" />
    <link rel="next" title="监控集群" href="../monitoring/" />
    <link rel="prev" title="操纵集群" href="../operating/" /> 
</head>

<body class="wy-body-for-nav">

   
  <header class="top-bar">
    <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../">Ceph 存储集群</a></li>
          <li class="breadcrumb-item"><a href="../">集群运维</a></li>
      <li class="breadcrumb-item active">健康检查</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../_sources/rados/operations/health-checks.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
  </header>
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #eee" >
          

          
            <a href="../../../" class="icon icon-home"> Ceph
          

          
          </a>

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search/" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../../start/">Ceph 简介</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../install/">安装 Ceph</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../cephadm/">Cephadm</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../">Ceph 存储集群</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../../configuration/">配置</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../">运维</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../operating/">操纵集群</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">健康检查</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id2">概览</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id3">状态定义</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../monitoring/">监控集群</a></li>
<li class="toctree-l3"><a class="reference internal" href="../monitoring-osd-pg/">监控 OSD 和归置组</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-management/">用户管理</a></li>
<li class="toctree-l3"><a class="reference internal" href="../pgcalc/">PG Calc</a></li>
<li class="toctree-l3"><a class="reference internal" href="../data-placement/">数据归置概览</a></li>
<li class="toctree-l3"><a class="reference internal" href="../pools/">存储池</a></li>
<li class="toctree-l3"><a class="reference internal" href="../erasure-code/">纠删码</a></li>
<li class="toctree-l3"><a class="reference internal" href="../cache-tiering/">分级缓存</a></li>
<li class="toctree-l3"><a class="reference internal" href="../placement-groups/">归置组</a></li>
<li class="toctree-l3"><a class="reference internal" href="../upmap/">使用 pg-upmap</a></li>
<li class="toctree-l3"><a class="reference internal" href="../read-balancer/">Operating the Read (Primary) Balancer</a></li>
<li class="toctree-l3"><a class="reference internal" href="../balancer/">均衡器模块</a></li>
<li class="toctree-l3"><a class="reference internal" href="../crush-map/">CRUSH 图</a></li>
<li class="toctree-l3"><a class="reference internal" href="../crush-map-edits/">手动编辑一个 CRUSH 图</a></li>
<li class="toctree-l3"><a class="reference internal" href="../stretch-mode/">Stretch Clusters</a></li>
<li class="toctree-l3"><a class="reference internal" href="../change-mon-elections/">Configuring Monitor Election Strategies</a></li>
<li class="toctree-l3"><a class="reference internal" href="../add-or-rm-osds/">增加/删除 OSD</a></li>
<li class="toctree-l3"><a class="reference internal" href="../add-or-rm-mons/">增加/删除监视器</a></li>
<li class="toctree-l3"><a class="reference internal" href="../devices/">设备管理</a></li>
<li class="toctree-l3"><a class="reference internal" href="../bluestore-migration/">迁移到 BlueStore</a></li>
<li class="toctree-l3"><a class="reference internal" href="../control/">命令参考</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../troubleshooting/community/">Ceph 社区</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../troubleshooting/troubleshooting-mon/">监视器故障排除</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../troubleshooting/troubleshooting-osd/">OSD 故障排除</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../troubleshooting/troubleshooting-pg/">归置组排障</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../troubleshooting/log-and-debug/">日志记录和调试</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../troubleshooting/cpu-profiling/">CPU 剖析</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../troubleshooting/memory-profiling/">内存剖析</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../man/">    手册页</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../troubleshooting/">故障排除</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../api/">APIs</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../cephfs/">Ceph 文件系统</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../rbd/">Ceph 块设备</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../radosgw/">Ceph 对象网关</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../mgr/">Ceph 管理器守护进程</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../mgr/dashboard/">Ceph 仪表盘</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../monitoring/">监控概览</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/">API 文档</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../architecture/">体系结构</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../dev/developer_guide/">开发者指南</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../dev/internals/">Ceph 内幕</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../governance/">项目管理</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../foundation/">Ceph 基金会</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../ceph-volume/">ceph-volume</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../crimson/crimson/">Crimson (Tech Preview)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../releases/general/">Ceph 版本（总目录）</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../releases/">Ceph 版本（索引）</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../security/">Security</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../hardware-monitoring/">硬件监控</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../glossary/">Ceph 术语</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../jaegertracing/">Tracing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../translation_cn/">中文版翻译资源</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../">Ceph</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
<div id="dev-warning" class="admonition note">
  <p class="first admonition-title">Notice</p>
  <p class="last">This document is for a development version of Ceph.</p>
</div>
  <div id="docubetter" align="right" style="padding: 5px; font-weight: bold;">
    <a href="https://pad.ceph.com/p/Report_Documentation_Bugs">Report a Documentation Bug</a>
  </div>

  
  <section id="health-checks">
<span id="id1"></span><h1>健康检查<a class="headerlink" href="#health-checks" title="Permalink to this heading"></a></h1>
<section id="id2">
<h2>概览<a class="headerlink" href="#id2" title="Permalink to this heading"></a></h2>
<p>Ceph 集群可能产生的健康消息是有限的——它们通通被定义为<em>健康检查</em>，都有唯一标识符。</p>
<p>标识符（ identifier ）是一个简洁的人类可读字符串，也就是说，
标识符的可读性与典型的变量名基本相同。其目的是使工具
（比如监视器和用户界面）能够理解健康检查，并以字面含义的方式呈现健康检查结果。</p>
<p>本页列出了监视器和管理器守护进程产生的健康检查。此外，
您还可能看到来自 CephFS MDS 守护进程的健康检查
（见 <a class="reference internal" href="../../../cephfs/health-messages/#cephfs-health-messages"><span class="std std-ref">CephFS 健康消息</span></a> ），以及由 <code class="docutils literal notranslate"><span class="pre">ceph-mgr</span></code> 模块定义的健康检查。</p>
</section>
<section id="id3">
<h2>状态定义<a class="headerlink" href="#id3" title="Permalink to this heading"></a></h2>
<section id="id4">
<h3>监视器<a class="headerlink" href="#id4" title="Permalink to this heading"></a></h3>
<section id="daemon-old-version">
<h4>DAEMON_OLD_VERSION<a class="headerlink" href="#daemon-old-version" title="Permalink to this heading"></a></h4>
<p>一个或多个 Ceph 守护进程正在运行旧版的 Ceph 。如果检测到多个版本，
就会产生健康检查。这种情况存在的时间必须大于 <code class="docutils literal notranslate"><span class="pre">mon_warn_older_version_delay</span></code>
（默认为一周），健康检查才会触发。这样，大多数升级就可以继续进行，
而不会引发预期和短暂的警告。如果升级暂停的时间较长，可以执行
<code class="docutils literal notranslate"><span class="pre">ceph</span> <span class="pre">health</span> <span class="pre">mute</span> <span class="pre">DAEMON_OLD_VERSION</span> <span class="pre">--sticky</span></code> 来达到 <code class="docutils literal notranslate"><span class="pre">health</span> <span class="pre">mute</span></code> 。
不过，请务必在升级完成后运行 <code class="docutils literal notranslate"><span class="pre">ceph</span> <span class="pre">health</span> <span class="pre">unmute</span> <span class="pre">DAEMON_OLD_VERSION</span></code> ，
这样以后出现意外情况就不会被屏蔽。</p>
</section>
<section id="mon-down">
<h4>MON_DOWN<a class="headerlink" href="#mon-down" title="Permalink to this heading"></a></h4>
<p>一个或多个 Ceph 监视器守护进程宕机了。
集群要求大多数（一半以上）已装好的监视器可用。
当一个或多个监视器宕机时，客户端可能会更难与集群建立初始连接，
因为它们可能需要另外尝试其他 IP 地址才能连上正常运行的监视器。</p>
<p>应尽快恢复或重启宕机的监视器守护进程，
以降低更多监视器故障可能导致服务中断的风险。</p>
</section>
<section id="mon-clock-skew">
<h4>MON_CLOCK_SKEW<a class="headerlink" href="#mon-clock-skew" title="Permalink to this heading"></a></h4>
<p>运行着 Ceph 监视器守护进程的主机，它们的时钟不同步。
如果集群检测到的时钟偏移大于 <a class="reference internal" href="../../configuration/mon-config-ref/#confval-mon_clock_drift_allowed"><code class="xref std std-confval docutils literal notranslate"><span class="pre">mon_clock_drift_allowed</span></code></a> ），
就会触发这个健康检查。</p>
<p>解决这一问题的最佳方法是用比如传统的 <code class="docutils literal notranslate"><span class="pre">ntpd</span></code>
或较新的 <code class="docutils literal notranslate"><span class="pre">chrony</span></code> 等工具同步时钟。
为提高可靠性，最好配置 NTP 守护进程与多个内部和外部时钟源同步；
此协议能自主确定最佳可用源。
另外，让 Ceph 监视器主机上的 NTP 守护进程相互同步也有好处，
与基准时间之间的误差<strong>准确</strong>相比，
监视器之间相互同步甚至更重要。</p>
<p>如果保持时钟紧密同步不切实际，
可以增大 <a class="reference internal" href="../../configuration/mon-config-ref/#confval-mon_clock_drift_allowed"><code class="xref std std-confval docutils literal notranslate"><span class="pre">mon_clock_drift_allowed</span></code></a> 阈值。
但是，该值必须大大低于 <code class="docutils literal notranslate"><span class="pre">mon_lease</span></code> 间隔，
这样监控器集群才能正常运行。
用高质量的 NTP 或 PTP 配置实现亚毫秒级的时间同步并不难，
因此，很少有必要更改此值。</p>
</section>
<section id="mon-msgr2-not-enabled">
<h4>MON_MSGR2_NOT_ENABLED<a class="headerlink" href="#mon-msgr2-not-enabled" title="Permalink to this heading"></a></h4>
<p>启用了 <code class="xref std std-confval docutils literal notranslate"><span class="pre">ms_bind_msgr2</span></code> 选项，但集群 monmap 中有一个或多个监视器没有配置绑定到 v2 端口。
这意味着 msgr2 协议特有的功能（如加密）在一些或所有连接上不可用。</p>
<p>在大多数情况下，执行下列命令可纠正这一问题：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><style type="text/css">
span.prompt1:before {
  content: "$ ";
}
</style><span class="prompt1">ceph<span class="w"> </span>mon<span class="w"> </span>enable-msgr2</span>
</pre></div></div><p>运行此命令后，任何配置为监听旧默认端口（6789）
的监视器将继续监听 6789 上的 v1 连接，
并开始监听新默认端口 3300 上的 v2 连接。</p>
<p>如果监视器配置为在非标准端口
（即 6789 以外的端口）上监听 v1 连接，
则需要手动修改 monmap 。</p>
</section>
<section id="mon-disk-low">
<h4>MON_DISK_LOW<a class="headerlink" href="#mon-disk-low" title="Permalink to this heading"></a></h4>
<p>一个或多个监视器的存储空间不足。
如果监视器数据库（通常为 <code class="docutils literal notranslate"><span class="pre">/var/lib/ceph/&lt;fsid&gt;/mon.&lt;monid&gt;</span></code> ）
所在文件系统上的可用空间百分比低于 <a class="reference internal" href="../../configuration/mon-config-ref/#confval-mon_data_avail_warn"><code class="xref std std-confval docutils literal notranslate"><span class="pre">mon_data_avail_warn</span></code></a> 百分比数值
（默认：30%），就会触发这个健康检查。</p>
<p>该警报可能表明系统中有其他进程或用户正在填满监视器所用的文件系统。它还可能预示着监视器数据库过大（参阅下文 <code class="docutils literal notranslate"><span class="pre">MON_DISK_BIG</span></code> ）。
另一种常见情况是，之前为了排除故障提高了 Ceph 日志子系统级别，
但随后并未恢复到默认级别。
持续的详尽日志记录很容易填满 <code class="docutils literal notranslate"><span class="pre">/var/log</span></code> 所在的文件系统。
如果要修剪当前已打开的日志，记得重启，
或者指示 syslog 或其他守护进程重新打开这个日志文件。
另一种常见情形是用户或者进程曾向 <code class="docutils literal notranslate"><span class="pre">/tmp</span></code> 或 <code class="docutils literal notranslate"><span class="pre">/var/tmp</span></code>
写入过大量数据，而它们可能位于同一个文件系统之内。</p>
<p>如果无法释放空间，那就可能需要把监视器的数据目录移到其他存储设备或文件系统
（此搬迁过程必须在监视器守护进程未运行时进行）。</p>
</section>
<section id="mon-disk-crit">
<h4>MON_DISK_CRIT<a class="headerlink" href="#mon-disk-crit" title="Permalink to this heading"></a></h4>
<p>一个或多个监视器的存储空间严重不足。如果监视器数据库
（通常为 <code class="docutils literal notranslate"><span class="pre">/var/lib/ceph/&lt;fsid&gt;/mon.&lt;monid&gt;</span></code> ）所在文件系统的可用空间百分比低于 <a class="reference internal" href="../../configuration/mon-config-ref/#confval-mon_data_avail_crit"><code class="xref std std-confval docutils literal notranslate"><span class="pre">mon_data_avail_crit</span></code></a>
百分比值（默认：5%），就会触发这个健康检查。
参阅上文的 <code class="docutils literal notranslate"><span class="pre">MON_DISK_LOW</span></code> 。</p>
</section>
<section id="mon-disk-big">
<h4>MON_DISK_BIG<a class="headerlink" href="#mon-disk-big" title="Permalink to this heading"></a></h4>
<p>一个或多个监视器的数据库容量非常大。
如果监控器数据库的尺寸大于
<a class="reference internal" href="../../configuration/mon-config-ref/#confval-mon_data_size_warn"><code class="xref std std-confval docutils literal notranslate"><span class="pre">mon_data_size_warn</span></code></a> （默认值： 15 GiB ）。</p>
<p>数据库过于大是不正常的，但并不一定表示有问题。
当有一些归置组很长时间没有达到 <code class="docutils literal notranslate"><span class="pre">active+clean</span></code> 状态，
或者最近发生了大量的集群恢复、扩展或拓扑变化时，
监视器数据库的尺寸可能会增大。
建议在进行大规模集群变更时，每周让集群“休整”至少数小时。</p>
<p>此警报还表明监视器的数据库可能没有正确压缩，
这个问题在某些旧版的 RocksDB 中也曾出现过。
用 <code class="docutils literal notranslate"><span class="pre">ceph</span> <span class="pre">daemon</span> <span class="pre">mon.&lt;id&gt;</span> <span class="pre">compact</span></code> 强制压缩可以大大降低数据库的存储空间使用。</p>
<p>此警报还表明监视器可能存在一个缺陷，
导致它无法修剪其存储的集群元数据。
如果问题持续存在，请报告此 bug 。</p>
<p>要调整警告阈值，执行下列命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1">ceph<span class="w"> </span>config<span class="w"> </span><span class="nb">set</span><span class="w"> </span>global<span class="w"> </span>mon_data_size_warn<span class="w"> </span>&lt;size&gt;</span>
</pre></div></div></section>
<section id="mon-netsplit">
<h4>MON_NETSPLIT<a class="headerlink" href="#mon-netsplit" title="Permalink to this heading"></a></h4>
<p>Ceph 监视器集群内发生了网络分裂。基于对每个连接持续更新的评分记录，
当至少有一个监视器检测到：至少有两个 Ceph 监视器连接不上或不可达时，
就会触发此健康检查。只有集群配置了三个以上 Ceph 监视器、
并采用 <code class="docutils literal notranslate"><span class="pre">connectivity</span></code> <a class="reference internal" href="../change-mon-elections/#changing-monitor-elections"><span class="std std-ref">选举策略</span></a>时，才会出现此警告。</p>
<p>为减少因网络瞬态问题引发的误报，
检测到的网络分裂不会立即作为健康警告报告。
相反，它们必须持续至少 <code class="xref std std-confval docutils literal notranslate"><span class="pre">mon_netsplit_grace_period</span></code> 秒（默认值：9 秒）才会报告出去。
如果网络分裂在此宽限期内自动恢复，就不会发出健康警告。</p>
<p>网络分裂有两种报告方式：</p>
<ul class="simple">
<li><p>对于地理位置级的网络分裂（如 “Netsplit detected between dc1 and dc2”
［在 dc1 和 dc2 之间检测到了网络分裂］），
是一个位置上的所有监视器无法与另一个位置上的所有监视器通信。</p></li>
<li><p>对于单个监视器的网络分裂（如 “Netsplit detected between mon.a and mon.d”
［在 mon.a 和 mon.d 之间检测到网络分裂］），是个别位于其他地方的监视器断开连接。</p></li>
</ul>
<p>系统会尽可能优先报告最高拓扑级别（ <code class="docutils literal notranslate"><span class="pre">datacenter</span></code> 、 <code class="docutils literal notranslate"><span class="pre">rack</span></code> 等）的问题，
以更准确地帮助运维人员确定基础设施级别的网络问题。</p>
<p>要调整宽限期阈值，执行下列命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><style type="text/css">
span.prompt2:before {
  content: "# ";
}
</style><span class="prompt2">ceph<span class="w"> </span>config<span class="w"> </span><span class="nb">set</span><span class="w"> </span>mon<span class="w"> </span>mon_netsplit_grace_period<span class="w"> </span>&lt;seconds&gt;</span>
</pre></div></div><p>要完全禁用宽限期（立即报告），把此值设置为 0 ：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt2">ceph<span class="w"> </span>config<span class="w"> </span><span class="nb">set</span><span class="w"> </span>mon<span class="w"> </span>mon_netsplit_grace_period<span class="w"> </span><span class="m">0</span></span>
</pre></div></div></section>
<section id="auth-insecure-global-id-reclaim">
<h4>AUTH_INSECURE_GLOBAL_ID_RECLAIM<a class="headerlink" href="#auth-insecure-global-id-reclaim" title="Permalink to this heading"></a></h4>
<p>重新连接到监视器时，连接到集群的一个或多个客户端/守护进程没有安全地重申它们的
<code class="docutils literal notranslate"><span class="pre">global_id</span></code> （标识集群中每个成员的唯一数字标识符）。
这样的客户端还是会被允许连接，原因是：
<code class="xref std std-confval docutils literal notranslate"><span class="pre">auth_allow_insecure_global_id_reclaim</span></code> 选项被设置成了 <code class="docutils literal notranslate"><span class="pre">true</span></code>
（在所有 Ceph 客户端都完成升级之前，这是必要的），
而且 <code class="xref std std-confval docutils literal notranslate"><span class="pre">auth_expose_insecure_global_id_reclaim</span></code> 选项被设置成了 <code class="docutils literal notranslate"><span class="pre">true</span></code>
（可以让监视器更快地检测到“不安全重申（ insecure reclaim ）”的客户端，
以便稍后完成初始身份验证后、强制这些客户端立即重连）。</p>
<p>要确定哪些客户端在用未打补丁的 Ceph 客户端代码，
执行下列命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1">ceph<span class="w"> </span>health<span class="w"> </span>detail</span>
</pre></div></div><p>如果收集到连入单个监控器的客户端们的转储，
并检查转储输出中的 <code class="docutils literal notranslate"><span class="pre">global_id_status</span></code> 字段，
你就能看到这些客户端的 <code class="docutils literal notranslate"><span class="pre">global_id</span></code> 重申行为。
这里的 <code class="docutils literal notranslate"><span class="pre">reclaim_insecure</span></code> 表示客户端未打补丁，并导致了这次健康检查。
要生成客户端转储，执行下列命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1">ceph<span class="w"> </span>tell<span class="w"> </span>mon.<span class="se">\*</span><span class="w"> </span>sessions</span>
</pre></div></div><p>我们强烈建议将系统中的所有客户端升级到能正确重申 <code class="docutils literal notranslate"><span class="pre">global_id</span></code> 值的 Ceph 更高版本。
升级所有客户端后，执行下列命令，不再允许不安全的重连：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1">ceph<span class="w"> </span>config<span class="w"> </span><span class="nb">set</span><span class="w"> </span>mon<span class="w"> </span>auth_allow_insecure_global_id_reclaim<span class="w"> </span><span class="nb">false</span></span>
</pre></div></div><p>如果立即升级所有客户端办不到，可以临时把这个警告<a class="reference internal" href="../monitoring/#rados-monitoring-muting-health-checks"><span class="std std-ref">消音</span></a>，
执行下列命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1">ceph<span class="w"> </span>health<span class="w"> </span>mute<span class="w"> </span>AUTH_INSECURE_GLOBAL_ID_RECLAIM<span class="w"> </span>1w<span class="w">   </span><span class="c1"># 1 week</span></span>
</pre></div></div><p>虽然我们<strong>不建议</strong>你这样做，但是，确实可以永久禁用此警告，
执行下列命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1">ceph<span class="w"> </span>config<span class="w"> </span><span class="nb">set</span><span class="w"> </span>mon<span class="w"> </span>mon_warn_on_insecure_global_id_reclaim<span class="w"> </span><span class="nb">false</span></span>
</pre></div></div></section>
<section id="auth-insecure-global-id-reclaim-allowed">
<h4>AUTH_INSECURE_GLOBAL_ID_RECLAIM_ALLOWED<a class="headerlink" href="#auth-insecure-global-id-reclaim-allowed" title="Permalink to this heading"></a></h4>
<p>Ceph 目前的配置允许客户端们通过不安全的过程重连监视器，
并重申它们之前的 <code class="docutils literal notranslate"><span class="pre">global_id</span></code> 。之所以允许这种重申，
是因为 <code class="xref std std-confval docutils literal notranslate"><span class="pre">auth_allow_insecure_global_id_reclaim</span></code> 默认被设置为 <code class="docutils literal notranslate"><span class="pre">true</span></code> 。
即使现有的 Ceph 客户端升级到能正确、
安全地重申其 <code class="docutils literal notranslate"><span class="pre">global_id</span></code> 的 Ceph 更新版本后，
可能还是有必要保留此设置。</p>
<p>如果 <code class="docutils literal notranslate"><span class="pre">AUTH_INSECURE_GLOBAL_ID_RECLAIM</span></code> 健康检查未被触发，
并且 <code class="xref std std-confval docutils literal notranslate"><span class="pre">auth_expose_insecure_global_id_reclaim</span></code> 设置未被禁用
（默认已启用），那就说明当前没有连入需要升级的客户端。
在这种情况下，可以安全地禁用不安全的 <code class="docutils literal notranslate"><span class="pre">global_id</span></code> 重申，
执行下列命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1">ceph<span class="w"> </span>config<span class="w"> </span><span class="nb">set</span><span class="w"> </span>mon<span class="w"> </span>auth_allow_insecure_global_id_reclaim<span class="w"> </span><span class="nb">false</span></span>
</pre></div></div><p>相反，如果还有客户端需要升级，
那就可以临时<a class="reference internal" href="../monitoring/#rados-monitoring-muting-health-checks"><span class="std std-ref">消音</span></a>此警告，
执行下列命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1">ceph<span class="w"> </span>health<span class="w"> </span>mute<span class="w"> </span>AUTH_INSECURE_GLOBAL_ID_RECLAIM_ALLOWED<span class="w"> </span>1w<span class="w">   </span><span class="c1"># 1 week</span></span>
</pre></div></div><p>虽然我们<strong>不建议</strong>这样做，但是，确实可以永久禁用此警告，
执行下列命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1">ceph<span class="w"> </span>config<span class="w"> </span><span class="nb">set</span><span class="w"> </span>mon<span class="w"> </span>mon_warn_on_insecure_global_id_reclaim_allowed<span class="w"> </span><span class="nb">false</span></span>
</pre></div></div></section>
</section>
<section id="id5">
<h3>管理器<a class="headerlink" href="#id5" title="Permalink to this heading"></a></h3>
<section id="mgr-down">
<h4>MGR_DOWN<a class="headerlink" href="#mgr-down" title="Permalink to this heading"></a></h4>
<p>现在，所有 Ceph 管理器守护进程都已关闭。通常情况下，
集群应该有至少一个运行着的管理器（ <code class="docutils literal notranslate"><span class="pre">ceph-mgr</span></code> ）守护进程。
如果没有管理器守护进程在运行，集群监控自身的能力将受到影响，
一部分管理 API 功能将不可用（例如，仪表盘将无法工作，
报告指标或运行时状态的大多数 CLI 命令将阻塞）。
不过，集群仍能执行客户端 I/O 操作并从故障中恢复。</p>
<p>应尽快重启宕机的管理器守护进程，
以确保可以监控集群（例如，这样 <code class="docutils literal notranslate"><span class="pre">ceph</span> <span class="pre">-s</span></code> 信息就可用且是最新的，这样 Prometheus 也能抓取指标）。</p>
</section>
<section id="mgr-module-dependency">
<h4>MGR_MODULE_DEPENDENCY<a class="headerlink" href="#mgr-module-dependency" title="Permalink to this heading"></a></h4>
<p>已启用的管理器模块，其依赖性检查失败。
这种健康检查通常会附带模块对问题的解释信息。</p>
<p>例如，模块可能报告未安装所需软件包：
在这种情况下，应安装所需软件包并重启管理器守护进程。</p>
<p>这个健康检查仅适用于已启用的模块。
如果模块未启用，可以从 <code class="docutils literal notranslate"><span class="pre">ceph</span> <span class="pre">module</span> <span class="pre">ls</span></code> 的输出中查看它是否存在依赖问题。</p>
</section>
<section id="mgr-module-error">
<h4>MGR_MODULE_ERROR<a class="headerlink" href="#mgr-module-error" title="Permalink to this heading"></a></h4>
<p>管理器模块出现意外错误。通常，
这意味着模块的 <code class="docutils literal notranslate"><span class="pre">serve()</span></code> 函数出现了一个未处理的异常。
如果异常自身没有提供有用的描述，
那么，给人看的错误描述可能也是措辞模糊。</p>
<p>这样的健康检查说明可能存在缺陷：如果您认为遇到了 bug ，
请开一个 Ceph bug 报告。</p>
<p>不过，如果您认为这个错误是暂时的，可以重新启动管理器守护进程，
或者在活跃守护进程上用 <code class="docutils literal notranslate"><span class="pre">ceph</span> <span class="pre">mgr</span> <span class="pre">fail</span></code> 强制切换到另一个守护进程。</p>
</section>
</section>
<section id="osds">
<h3>OSDs<a class="headerlink" href="#osds" title="Permalink to this heading"></a></h3>
<section id="osd-down">
<h4>OSD_DOWN<a class="headerlink" href="#osd-down" title="Permalink to this heading"></a></h4>
<p>至少有一个 OSD 被标记成了 <code class="docutils literal notranslate"><span class="pre">down</span></code> 状态，其 <code class="docutils literal notranslate"><span class="pre">ceph-osd</span></code> 守护进程或者它们所在主机可能已经奔溃或关闭了、
或者是对端 OSD 与此 OSD 之间的公共网/私有网不通。
常见起因有守护进程停止或崩溃、主机挂了、或者网络故障。</p>
<p>核实一下此主机是否健康、守护进程是否启动、网络是否正常。
如果那个守护进程崩溃了，其守护进程日志文件
（ <code class="docutils literal notranslate"><span class="pre">/var/log/ceph/ceph-osd.*</span></code> ）里会包含调试信息。</p>
</section>
<section id="osd-crush-type-down">
<h4>OSD_&lt;crush type&gt;_DOWN<a class="headerlink" href="#osd-crush-type-down" title="Permalink to this heading"></a></h4>
<p>(例如 OSD_HOST_DOWN, OSD_ROOT_DOWN)</p>
<p>某一个 CRUSH 子树里的所有 OSD 都被标记成了 down （例如，一台主机上的所有 OSD ）。</p>
</section>
<section id="osd-orphan">
<h4>OSD_ORPHAN<a class="headerlink" href="#osd-orphan" title="Permalink to this heading"></a></h4>
<p>CRUSH 图分级结构里提到了这个 OSD ，但它并不存在。</p>
<p>CRUSH 图分级结构里的这个 OSD 可以用以下命令删除：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1">ceph<span class="w"> </span>osd<span class="w"> </span>crush<span class="w"> </span>rm<span class="w"> </span>osd.&lt;id&gt;</span>
</pre></div></div></section>
<section id="osd-out-of-order-full">
<h4>OSD_OUT_OF_ORDER_FULL<a class="headerlink" href="#osd-out-of-order-full" title="Permalink to this heading"></a></h4>
<p>有关 <code class="docutils literal notranslate"><span class="pre">nearfull</span></code> 、 <code class="docutils literal notranslate"><span class="pre">backfillfull</span></code> 、 <code class="docutils literal notranslate"><span class="pre">full</span></code> 、和/或 <code class="docutils literal notranslate"><span class="pre">failsafe_full</span></code>
的利用率阈值不再增长。特别是，出现了以下情形： <code class="docutils literal notranslate"><span class="pre">nearfull</span></code> &lt; <code class="docutils literal notranslate"><span class="pre">backfillfull</span></code> 、
<code class="docutils literal notranslate"><span class="pre">backfillfull</span></code> &lt; <code class="docutils literal notranslate"><span class="pre">full</span></code> 、和 <code class="docutils literal notranslate"><span class="pre">full</span></code> &lt; <code class="docutils literal notranslate"><span class="pre">failsafe_full</span></code> 。
这样集群会出现意外行为。</p>
<p>要调整这些利用率阈值，执行下列命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1">ceph<span class="w"> </span>osd<span class="w"> </span>set-nearfull-ratio<span class="w"> </span>&lt;ratio&gt;</span>
<span class="prompt1">ceph<span class="w"> </span>osd<span class="w"> </span>set-backfillfull-ratio<span class="w"> </span>&lt;ratio&gt;</span>
<span class="prompt1">ceph<span class="w"> </span>osd<span class="w"> </span>set-full-ratio<span class="w"> </span>&lt;ratio&gt;</span>
</pre></div></div></section>
<section id="osd-full">
<h4>OSD_FULL<a class="headerlink" href="#osd-full" title="Permalink to this heading"></a></h4>
<p>至少一个 OSD 已经超过了 <code class="docutils literal notranslate"><span class="pre">full</span></code> 阈值，并且导致集群不再允许写入。</p>
<p>要按存储池检查利用率，执行下列命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt2">ceph<span class="w"> </span>df</span>
</pre></div></div><p>要查看当前设置的 <code class="docutils literal notranslate"><span class="pre">full</span></code> 比率，执行下列命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt2">ceph<span class="w"> </span>osd<span class="w"> </span>dump<span class="w"> </span><span class="p">|</span><span class="w"> </span>grep<span class="w"> </span>full_ratio</span>
</pre></div></div><p>恢复写入服务可用性的短期解决方法是把 full 阈值提高一点。
可以执行下列命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt2">ceph<span class="w"> </span>osd<span class="w"> </span>set-full-ratio<span class="w"> </span>&lt;ratio&gt;</span>
</pre></div></div><p>关于排查 OSD 空余空间问题的详细讨论，参见
<a class="reference internal" href="../../troubleshooting/troubleshooting-osd/#no-free-drive-space"><span class="std std-ref">OSD 故障排查</span></a>。</p>
<p>应该在恰当的 CRUSH 故障域里面额外部署一些 OSD ，
以增加容量，并/或删除现有数据，以释放集群空间。
一个不易察觉的情况是，之前用 <code class="docutils literal notranslate"><span class="pre">rados</span> <span class="pre">bench</span></code> 工具测试一个或多个存储池的性能，
而由此产生的 RADOS 对象随后却没有清理。
你可以对每个存储池调用 <code class="docutils literal notranslate"><span class="pre">rados</span> <span class="pre">ls</span></code> 来检查这种情况，
并查找以 <code class="docutils literal notranslate"><span class="pre">bench</span></code> 或其他任务名字打头的对象。
可以手动删除这些对象，以回收容量，但需要非常非常谨慎。</p>
</section>
<section id="osd-backfillfull">
<h4>OSD_BACKFILLFULL<a class="headerlink" href="#osd-backfillfull" title="Permalink to this heading"></a></h4>
<p>一个或多个 OSD 已超过 <code class="docutils literal notranslate"><span class="pre">backfillfull</span></code> 阈值，
或当前已映射好的回填完成后<em>会</em>超过此阈值，
它会妨碍数据重均衡到这个 OSD 。这个警报是一个预先警告，
表明重均衡可能无法完成，而且集群已接近用满。</p>
<p>要查看每个存储池的利用率，执行下列命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1">ceph<span class="w"> </span>df</span>
</pre></div></div><p>关于排查 OSD 空余空间问题的详细讨论，参见
<a class="reference internal" href="../../troubleshooting/troubleshooting-osd/#no-free-drive-space"><span class="std std-ref">OSD 故障排查</span></a>。</p>
</section>
<section id="osd-nearfull">
<h4>OSD_NEARFULL<a class="headerlink" href="#osd-nearfull" title="Permalink to this heading"></a></h4>
<p>一个或多个 OSD 已超过 <code class="docutils literal notranslate"><span class="pre">nearfull</span></code> 阈值。
这个警报是一个预先警告，表明集群快满了。</p>
<p>要查看每个存储池的利用率，执行下列命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1">ceph<span class="w"> </span>df</span>
</pre></div></div><p>关于排查 OSD 空余空间问题的详细讨论，参见
<a class="reference internal" href="../../troubleshooting/troubleshooting-osd/#no-free-drive-space"><span class="std std-ref">OSD 故障排查</span></a>。</p>
</section>
<section id="osdmap-flags">
<h4>OSDMAP_FLAGS<a class="headerlink" href="#osdmap-flags" title="Permalink to this heading"></a></h4>
<p>已经设置了一个或多个需要关注的集群标志。这些标志包括：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">full</span></code> - 此集群被标记为满了，且不能提供写入服务。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pauserd</span></code>, <code class="docutils literal notranslate"><span class="pre">pausewr</span></code> - 有暂停的读出和写入</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">noup</span></code> - 不允许 OSD 们启动</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nodown</span></code> - OSD 故障报告正被忽略，
这意味着监视器不会把 OSD 标记为 <code class="docutils literal notranslate"><span class="pre">down</span></code> 。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">noin</span></code> - 之前被标记成 <code class="docutils literal notranslate"><span class="pre">out</span></code> 的 OSD 们，
重启之后不会重新被标记为 <code class="docutils literal notranslate"><span class="pre">in</span></code> 。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">noout</span></code> - 处于 <code class="docutils literal notranslate"><span class="pre">down</span></code> 状态的 OSD 们，
在经过配置的时间间隔后不会被标记为 <code class="docutils literal notranslate"><span class="pre">out</span></code> 。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nobackfill</span></code>, <code class="docutils literal notranslate"><span class="pre">norecover</span></code>, <code class="docutils literal notranslate"><span class="pre">norebalance</span></code> - 恢复或数据重均衡被暂停了。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">noscrub</span></code>, <code class="docutils literal notranslate"><span class="pre">nodeep_scrub</span></code> - 洗刷被禁用了</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">notieragent</span></code> - cache-tiering （缓存分级）活动被暂停了</p></li>
</ul>
<p>除了 <code class="docutils literal notranslate"><span class="pre">full</span></code> 以外，这些标记都可以用下列命令设置或清除：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1">ceph<span class="w"> </span>osd<span class="w"> </span><span class="nb">set</span><span class="w"> </span>&lt;flag&gt;</span>
<span class="prompt1">ceph<span class="w"> </span>osd<span class="w"> </span><span class="nb">unset</span><span class="w"> </span>&lt;flag&gt;</span>
</pre></div></div></section>
<section id="osd-flags">
<h4>OSD_FLAGS<a class="headerlink" href="#osd-flags" title="Permalink to this heading"></a></h4>
<p>至少一个 OSD 或 CRUSH {节点、设备类别} 设置了需要关注的标记。
这些标记包括：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">noup</span></code>: 不允许启动这些 OSD 们</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nodown</span></code>: 这些 OSD 的故障报告会被忽略</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">noin</span></code>: 在之前的一次故障中，如果这些 OSD 被自动标记成了 <code class="docutils literal notranslate"><span class="pre">out</span></code> ，
在它们启动后不会被标记为 <code class="docutils literal notranslate"><span class="pre">in</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">noout</span></code> - 处于 <code class="docutils literal notranslate"><span class="pre">down</span></code> 状态的 OSD 们，
在经过配置的时间间隔后不会被标记为 <code class="docutils literal notranslate"><span class="pre">out</span></code> 。</p></li>
</ul>
<p>这些标记可以批量设置和清除，执行下列命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1">ceph<span class="w"> </span>osd<span class="w"> </span>set-group<span class="w"> </span>&lt;flags&gt;<span class="w"> </span>&lt;who&gt;</span>
<span class="prompt1">ceph<span class="w"> </span>osd<span class="w"> </span>unset-group<span class="w"> </span>&lt;flags&gt;<span class="w"> </span>&lt;who&gt;</span>
</pre></div></div><p>例如：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1">ceph<span class="w"> </span>osd<span class="w"> </span>set-group<span class="w"> </span>noup,noout<span class="w"> </span>osd.0<span class="w"> </span>osd.1</span>
<span class="prompt1">ceph<span class="w"> </span>osd<span class="w"> </span>unset-group<span class="w"> </span>noup,noout<span class="w"> </span>osd.0<span class="w"> </span>osd.1</span>
<span class="prompt1">ceph<span class="w"> </span>osd<span class="w"> </span>set-group<span class="w"> </span>noup,noout<span class="w"> </span>host-foo</span>
<span class="prompt1">ceph<span class="w"> </span>osd<span class="w"> </span>unset-group<span class="w"> </span>noup,noout<span class="w"> </span>host-foo</span>
<span class="prompt1">ceph<span class="w"> </span>osd<span class="w"> </span>set-group<span class="w"> </span>noup,noout<span class="w"> </span>class-hdd</span>
<span class="prompt1">ceph<span class="w"> </span>osd<span class="w"> </span>unset-group<span class="w"> </span>noup,noout<span class="w"> </span>class-hdd</span>
</pre></div></div></section>
<section id="old-crush-tunables">
<h4>OLD_CRUSH_TUNABLES<a class="headerlink" href="#old-crush-tunables" title="Permalink to this heading"></a></h4>
<p>CRUSH 图在使用很老的选项，应该更新它。还能使用（即，可连接此集群的最老客户端版本号）而不会触发此健康告警的最老可调选项由
<a class="reference internal" href="../../configuration/mon-config-ref/#confval-mon_crush_min_required_version"><code class="xref std std-confval docutils literal notranslate"><span class="pre">mon_crush_min_required_version</span></code></a> 配置选项决定。
详情见 ref:<cite>crush-map-tunables</cite> 。</p>
</section>
<section id="old-crush-straw-calc-version">
<h4>OLD_CRUSH_STRAW_CALC_VERSION<a class="headerlink" href="#old-crush-straw-calc-version" title="Permalink to this heading"></a></h4>
<p>CRUSH 图在使用一个比较老的、非最优方法为 <code class="docutils literal notranslate"><span class="pre">straw</span></code> 桶计算中间权重值。</p>
<p>应该更新 CRUSH 图以使用较新的方法（即： <code class="docutils literal notranslate"><span class="pre">straw_calc_version=1</span></code> ）。
详情参阅 <a class="reference internal" href="../crush-map/#crush-map-tunables"><span class="std std-ref">可调选项</span></a> 。</p>
</section>
<section id="cache-pool-no-hit-set">
<h4>CACHE_POOL_NO_HIT_SET<a class="headerlink" href="#cache-pool-no-hit-set" title="Permalink to this heading"></a></h4>
<p>至少有一个缓存存储池没有配置 <em>hit set</em> 来跟踪利用率。
这个问题妨碍分层代理无法找出需要从缓存中刷回和驱逐的冷对象。</p>
<p>要配置缓存存储池的 hit set ，执行下列命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1">ceph<span class="w"> </span>osd<span class="w"> </span>pool<span class="w"> </span><span class="nb">set</span><span class="w"> </span>&lt;poolname&gt;<span class="w"> </span>hit_set_type<span class="w"> </span>&lt;type&gt;</span>
<span class="prompt1">ceph<span class="w"> </span>osd<span class="w"> </span>pool<span class="w"> </span><span class="nb">set</span><span class="w"> </span>&lt;poolname&gt;<span class="w"> </span>hit_set_period<span class="w"> </span>&lt;period-in-seconds&gt;</span>
<span class="prompt1">ceph<span class="w"> </span>osd<span class="w"> </span>pool<span class="w"> </span><span class="nb">set</span><span class="w"> </span>&lt;poolname&gt;<span class="w"> </span>hit_set_count<span class="w"> </span>&lt;number-of-hitsets&gt;</span>
<span class="prompt1">ceph<span class="w"> </span>osd<span class="w"> </span>pool<span class="w"> </span><span class="nb">set</span><span class="w"> </span>&lt;poolname&gt;<span class="w"> </span>hit_set_fpp<span class="w"> </span>&lt;target-false-positive-rate&gt;</span>
</pre></div></div></section>
<section id="osd-no-sortbitwise">
<h4>OSD_NO_SORTBITWISE<a class="headerlink" href="#osd-no-sortbitwise" title="Permalink to this heading"></a></h4>
<p>没有在跑 luminous v12.y.z 之前的 OSD ，但却没有设置 <code class="docutils literal notranslate"><span class="pre">sortbitwise</span></code> 标记。</p>
<p>运行 Luminous v12.y.z 或更高版软件的 OSD 要想启动，必须设置 <code class="docutils literal notranslate"><span class="pre">sortbitwise</span></code> 标记。
要想安全地设置这个标记，执行下列命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1">ceph<span class="w"> </span>osd<span class="w"> </span><span class="nb">set</span><span class="w"> </span>sortbitwise</span>
</pre></div></div></section>
<section id="osd-filestore">
<h4>OSD_FILESTORE<a class="headerlink" href="#osd-filestore" title="Permalink to this heading"></a></h4>
<p>如果 OSD 正在运行旧的 Filestore 后端，就发出警告。
Filestore OSD 后端已废弃；从 Ceph Luminous 版开始，
BlueStore 后端就成了默认的对象存储库。</p>
<p>Filestore OSD 不支持 mClock 调度器。因此，
Filestore OSD 的默认 <code class="docutils literal notranslate"><span class="pre">osd_op_queue</span></code> 设置成了 <code class="docutils literal notranslate"><span class="pre">wpq</span></code> ，
即使用户试图更改也会强制施行。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1">ceph<span class="w"> </span>report<span class="w"> </span><span class="p">|</span><span class="w"> </span>jq<span class="w"> </span>-c<span class="w"> </span><span class="s1">&#39;.&quot;osd_metadata&quot; | .[] | select(.osd_objectstore | contains(&quot;filestore&quot;)) | {id, osd_objectstore}&#39;</span></span>
</pre></div></div><div class="admonition important">
<p class="admonition-title">Important</p>
<p>要升级到 Reef 或者之后的版本，
必须首先把 Filestore OSD 迁移到 BlueStore 。</p>
</div>
<p>如果您正在把 Reef 之前的版本升级到 Reef 或更高版本，
但不方便立即<a class="reference internal" href="../bluestore-migration/#rados-operations-bluestore-migration"><span class="std std-ref">把 Filestore OSD 迁移到 BlueStore</span></a>，
可以执行下列命令，暂时<a class="reference internal" href="../monitoring/#rados-monitoring-muting-health-checks"><span class="std std-ref">消音</span></a> 此警报：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1">ceph<span class="w"> </span>health<span class="w"> </span>mute<span class="w"> </span>OSD_FILESTORE</span>
</pre></div></div><p>由于从 Filestore OSD 迁移到 BlueStore 需要相当长的时间才能完成，
我们建议您在更新 Reef 或后续版本之前尽早开始此步骤。</p>
</section>
<section id="osd-unreachable">
<h4>OSD_UNREACHABLE<a class="headerlink" href="#osd-unreachable" title="Permalink to this heading"></a></h4>
<p>至少有一个 OSD 注册的 v1/v2 公网地址不在定义的 <a class="reference internal" href="../../configuration/network-config-ref/#confval-public_network"><code class="xref std std-confval docutils literal notranslate"><span class="pre">public_network</span></code></a> 子网内，
导致这些无法访问的 OSD 无法与 ceph 客户端正常通信。</p>
<p>即使这些无法访问的 OSD 处于 up 状态，
rados 客户端也会由于这种不一致而挂起，直到 TCP 超时才出错。</p>
</section>
<section id="pool-full">
<h4>POOL_FULL<a class="headerlink" href="#pool-full" title="Permalink to this heading"></a></h4>
<p>至少有一个存储池已经达到了配额，且不再允许写入。</p>
<p>要查看存储池配额和利用率，执行下列命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1">ceph<span class="w"> </span>df<span class="w"> </span>detail</span>
</pre></div></div><p>关于 <code class="docutils literal notranslate"><span class="pre">ceph</span> <span class="pre">df</span></code> 命令的更多细节，
见<a class="reference internal" href="../monitoring/#rados-monitoring-pool-usage"><span class="std std-ref">检查集群的使用情况</span></a> 。</p>
<p>如果你想提高此存储池的配额，执行下列命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1">ceph<span class="w"> </span>osd<span class="w"> </span>pool<span class="w"> </span>set-quota<span class="w"> </span>&lt;poolname&gt;<span class="w"> </span>max_objects<span class="w"> </span>&lt;num-objects&gt;</span>
<span class="prompt1">ceph<span class="w"> </span>osd<span class="w"> </span>pool<span class="w"> </span>set-quota<span class="w"> </span>&lt;poolname&gt;<span class="w"> </span>max_bytes<span class="w"> </span>&lt;num-bytes&gt;</span>
</pre></div></div><p>如果不想，可以删除一些现有数据，以降低利用率。</p>
</section>
<section id="bluefs-spillover">
<h4>BLUEFS_SPILLOVER<a class="headerlink" href="#bluefs-spillover" title="Permalink to this heading"></a></h4>
<p>至少有一个使用 BlueStore 后端的 OSD 已分配了 DB 分区
（就是用于存储元数据的存储空间，通常位于速度较快的设备上），
但由于这部分空间已被填满，元数据已经“溢出（ spilled over ）”到速度较慢的设备上。
这未必是出错的情况，甚至也不是意料之外的行为，但可能导致性能下降。
如果管理员规划了让所有元数据都能装到速度较快的设备上，
那么此警报说明提供的空间不足。</p>
<p>要在所有 OSD 上禁用此警报，执行下列命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1">ceph<span class="w"> </span>config<span class="w"> </span><span class="nb">set</span><span class="w"> </span>osd<span class="w"> </span>bluestore_warn_on_bluefs_spillover<span class="w"> </span><span class="nb">false</span></span>
</pre></div></div><p>另外，还能禁用某一个指定 OSD 的警告，执行下列命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1">ceph<span class="w"> </span>config<span class="w"> </span><span class="nb">set</span><span class="w"> </span>osd.123<span class="w"> </span>bluestore_warn_on_bluefs_spillover<span class="w"> </span><span class="nb">false</span></span>
</pre></div></div><p>为了保证有更多的元数据空间，可以销毁并重新配置相关的 OSD 。
这个过程需要数据迁移和恢复。</p>
<p>也可能需要扩展支持 DB 存储所在的 LVM 逻辑卷。
如果底层 LV 已经扩展，则必须停止 OSD 守护进程，
并通知 BlueFS 设备大小变化了，执行下列命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1">ceph-bluestore-tool<span class="w"> </span>bluefs-bdev-expand<span class="w"> </span>--path<span class="w"> </span>/var/lib/ceph/osd/ceph-<span class="nv">$ID</span></span>
</pre></div></div></section>
<section id="bluefs-available-space">
<h4>BLUEFS_AVAILABLE_SPACE<a class="headerlink" href="#bluefs-available-space" title="Permalink to this heading"></a></h4>
<p>要查看 BlueFS 还有多少空闲空间，执行下列命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1">ceph<span class="w"> </span>daemon<span class="w"> </span>osd.123<span class="w"> </span>bluestore<span class="w"> </span>bluefs<span class="w"> </span>available</span>
</pre></div></div><p>此命令顶多输出这三个值： <code class="docutils literal notranslate"><span class="pre">BDEV_DB</span> <span class="pre">free</span></code> 、 <code class="docutils literal notranslate"><span class="pre">BDEV_SLOW</span> <span class="pre">free</span></code> 和
<code class="docutils literal notranslate"><span class="pre">available_from_bluestore</span></code> 。 <code class="docutils literal notranslate"><span class="pre">BDEV_DB</span></code> 和 <code class="docutils literal notranslate"><span class="pre">BDEV_SLOW</span></code> 报告的是
BlueFS 已申请到、但目前还被认为是空闲的空间尺寸。
<code class="docutils literal notranslate"><span class="pre">available_from_bluestore</span></code> 的数值表示 BlueStore 向 BlueFS 释放更多空间的能力。
由于 BlueFS 分配单元通常大于 BlueStore 分配单元，
因此该值与 BlueStore 可用空间的数值不同是正常的。
这意味着 BlueStore 空闲空间里只有一部分可供 BlueFS 使用。</p>
</section>
<section id="bluefs-low-space">
<h4>BLUEFS_LOW_SPACE<a class="headerlink" href="#bluefs-low-space" title="Permalink to this heading"></a></h4>
<p>如果 BlueFS 可用的空闲空间不足，而且 BlueStore 可用空闲空间不多
（换句话说， <code class="docutils literal notranslate"><span class="pre">bluestore</span> <span class="pre">max</span> <span class="pre">free</span></code> 的数值较低），
可以试试减少 BlueFS 分配单元的尺寸。
要模拟分配单元不同时的可用空间，执行下列命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1">ceph<span class="w"> </span>daemon<span class="w"> </span>osd.123<span class="w"> </span>bluestore<span class="w"> </span>bluefs<span class="w"> </span>available<span class="w"> </span>&lt;alloc-unit-size&gt;</span>
</pre></div></div></section>
<section id="bluestore-fragmentation">
<h4>BLUESTORE_FRAGMENTATION<a class="headerlink" href="#bluestore-fragmentation" title="Permalink to this heading"></a></h4>
<p><code class="docutils literal notranslate"><span class="pre">BLUESTORE_FRAGMENTATION</span></code> 表示 BlueStore 底层的可用空间都是碎片化的。
这是正常的、不可避免的现象，但过度碎片化会导致速度变慢。
要检查 BlueStore 碎片化情况，执行下列命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1">ceph<span class="w"> </span>daemon<span class="w"> </span>osd.123<span class="w"> </span>bluestore<span class="w"> </span>allocator<span class="w"> </span>score<span class="w"> </span>block</span>
</pre></div></div><p>碎片化的评分在 [0-1] 这个范围内。</p>
<ul class="simple">
<li><p>[0.0 .. 0.4] 轻微碎片化</p></li>
<li><p>[0.4 .. 0.7] 小的、可接受的碎片化</p></li>
<li><p>[0.7 .. 0.9] 比较多，但还算安全的碎片化</p></li>
<li><p>[0.9 .. 1.0] 严重碎片化，可能影响 BlueFS 从 BlueStore 获取空间的能力</p></li>
</ul>
<p>要查看空闲空间的碎片化详情，执行下列命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt2">ceph<span class="w"> </span>daemon<span class="w"> </span>osd.123<span class="w"> </span>bluestore<span class="w"> </span>allocator<span class="w"> </span>dump<span class="w"> </span>block</span>
</pre></div></div><p>对于当前进程没在运行的 OSD ，可以用 <strong class="program">ceph-bluestore-tool</strong> 检查碎片情况。
要查看碎片评分，执行下列命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt2">ceph-bluestore-tool<span class="w"> </span>--path<span class="w"> </span>/var/lib/ceph/osd/ceph-123<span class="w"> </span>--allocator<span class="w"> </span>block<span class="w"> </span>free-score</span>
</pre></div></div><p>要转储出详细的空闲块，执行下列命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt2">ceph-bluestore-tool<span class="w"> </span>--path<span class="w"> </span>/var/lib/ceph/osd/ceph-123<span class="w"> </span>--allocator<span class="w"> </span>block<span class="w"> </span>free-dump</span>
</pre></div></div></section>
<section id="bluestore-legacy-statfs">
<h4>BLUESTORE_LEGACY_STATFS<a class="headerlink" href="#bluestore-legacy-statfs" title="Permalink to this heading"></a></h4>
<p>至少有一个 OSD 的 BlueStore 卷是在 Nautilus 版本之前创建的。
(在 Nautilus 中， BlueStore 按每个存储池的粒度跟踪它的内部使用情况统计信息）。</p>
<p>如果<em>所有</em>的 OSD 都早于 Nautilus ，这就意味着根本无法获得每个存储池的指标。
但如果 Nautilus 之前的 OSD 和 Nautilus 之后的 OSD 混在一起，
<code class="docutils literal notranslate"><span class="pre">ceph</span> <span class="pre">df</span></code> 报告的集群利用率统计数据就会不准确。</p>
<p>可以更新一下老的 OSD 们，就可以用新的利用率跟踪方案了，这样操作：
停止每个 OSD 、运行修复操作，然后重启这个 OSD 。
例如，要更新 <code class="docutils literal notranslate"><span class="pre">osd.123</span></code> ，执行下列命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt2">systemctl<span class="w"> </span>stop<span class="w"> </span>ceph-osd@123</span>
<span class="prompt2">ceph-bluestore-tool<span class="w"> </span>repair<span class="w"> </span>--path<span class="w"> </span>/var/lib/ceph/osd/ceph-123</span>
<span class="prompt2">systemctl<span class="w"> </span>start<span class="w"> </span>ceph-osd@123</span>
</pre></div></div><p>要禁用此警报，执行下列命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt2">ceph<span class="w"> </span>config<span class="w"> </span><span class="nb">set</span><span class="w"> </span>global<span class="w"> </span>bluestore_warn_on_legacy_statfs<span class="w"> </span><span class="nb">false</span></span>
</pre></div></div></section>
<section id="bluestore-no-per-pool-omap">
<h4>BLUESTORE_NO_PER_POOL_OMAP<a class="headerlink" href="#bluestore-no-per-pool-omap" title="Permalink to this heading"></a></h4>
<p>至少有一个 OSD 的卷是在 Octopus 版本之前创建的。
(在 Octopus 及其后续版本中， BlueStore 按存储池跟踪 omap 空间利用率）。</p>
<p>如果有 BlueStore OSD 没启用新的跟踪方式，
集群将根据最近的深度洗刷结果报告每个存储池 omap 使用情况的近似值。</p>
<p>可以更新 OSD 们做到按存储池跟踪，这样操作：
停止每个 OSD 、运行修复操作，然后重启这个 OSD 。
例如，要更新 <code class="docutils literal notranslate"><span class="pre">osd.123</span></code> ，执行下列命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt2">systemctl<span class="w"> </span>stop<span class="w"> </span>ceph-osd@123</span>
<span class="prompt2">ceph-bluestore-tool<span class="w"> </span>repair<span class="w"> </span>--path<span class="w"> </span>/var/lib/ceph/osd/ceph-123</span>
<span class="prompt2">systemctl<span class="w"> </span>start<span class="w"> </span>ceph-osd@123</span>
</pre></div></div><p>要禁用此警报，执行下列命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt2">ceph<span class="w"> </span>config<span class="w"> </span><span class="nb">set</span><span class="w"> </span>global<span class="w"> </span>bluestore_warn_on_no_per_pool_omap<span class="w"> </span><span class="nb">false</span></span>
</pre></div></div></section>
<section id="bluestore-no-per-pg-omap">
<h4>BLUESTORE_NO_PER_PG_OMAP<a class="headerlink" href="#bluestore-no-per-pg-omap" title="Permalink to this heading"></a></h4>
<p>至少有一个 OSD 的卷是在 Pacific 之前创建的。
(在 Pacific 及其后续版本中， Bluestore 按归置组 (PG)
跟踪 omap 空间利用率）。</p>
<p>在 PG 迁移时，按 PG 划分的 omap 可以使 PG 删除速度更快。</p>
<p>可以更新一下老的 OSD ，让它按 PG 更新，这样操作：
停止每个 OSD 、运行修复操作，然后重启 OSD 。
例如，要更新 <code class="docutils literal notranslate"><span class="pre">osd.123</span></code> ，执行下列命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt2">systemctl<span class="w"> </span>stop<span class="w"> </span>ceph-osd@123</span>
<span class="prompt2">ceph-bluestore-tool<span class="w"> </span>repair<span class="w"> </span>--path<span class="w"> </span>/var/lib/ceph/osd/ceph-123</span>
<span class="prompt2">systemctl<span class="w"> </span>start<span class="w"> </span>ceph-osd@123</span>
</pre></div></div><p>要禁用此警报，执行下列命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt2">ceph<span class="w"> </span>config<span class="w"> </span><span class="nb">set</span><span class="w"> </span>global<span class="w"> </span>bluestore_warn_on_no_per_pg_omap<span class="w"> </span><span class="nb">false</span></span>
</pre></div></div></section>
<section id="bluestore-disk-size-mismatch">
<h4>BLUESTORE_DISK_SIZE_MISMATCH<a class="headerlink" href="#bluestore-disk-size-mismatch" title="Permalink to this heading"></a></h4>
<p>至少有一个 BlueStore OSD 存在内部不一致，
在物理设备大小与跟踪其大小的元数据之间。
这种不一致可能导致 OSD 以后发生崩溃。</p>
<p>存在这种不一致的 OSD 应该销毁并重新配置。
要非常小心，每次只在一个 OSD 上执行此过程，
以最小化丢失数据的风险。要完成此步骤，
其中 <code class="docutils literal notranslate"><span class="pre">$N</span></code> 是存在不一致的 OSD ，执行下列命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt2">ceph<span class="w"> </span>osd<span class="w"> </span>out<span class="w"> </span>osd.<span class="nv">$N</span></span>
<span class="prompt2"><span class="k">while</span><span class="w"> </span>!<span class="w"> </span>ceph<span class="w"> </span>osd<span class="w"> </span>safe-to-destroy<span class="w"> </span>osd.<span class="nv">$N</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="k">do</span><span class="w"> </span>sleep<span class="w"> </span>1m<span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="k">done</span></span>
<span class="prompt2">ceph<span class="w"> </span>osd<span class="w"> </span>destroy<span class="w"> </span>osd.<span class="nv">$N</span></span>
<span class="prompt2">ceph-volume<span class="w"> </span>lvm<span class="w"> </span>zap<span class="w"> </span>/path/to/device</span>
<span class="prompt2">ceph-volume<span class="w"> </span>lvm<span class="w"> </span>create<span class="w"> </span>--osd-id<span class="w"> </span><span class="nv">$N</span><span class="w"> </span>--data<span class="w"> </span>/path/to/device</span>
</pre></div></div><div class="admonition note">
<p class="admonition-title">Note</p>
<p>等着这个恢复过程在一个 OSD 上完成，再处理下一个。</p>
</div>
</section>
<section id="bluestore-no-compression">
<h4>BLUESTORE_NO_COMPRESSION<a class="headerlink" href="#bluestore-no-compression" title="Permalink to this heading"></a></h4>
<p>至少有一个 OSD 无法加载 BlueStore 压缩插件。
造成这一问题的原因可能是安装中断，
其中的 <code class="docutils literal notranslate"><span class="pre">ceph-osd</span></code> 二进制文件与压缩插件不匹配。
也可能是最近一次升级造成的，升级过程中未重新启动 <code class="docutils literal notranslate"><span class="pre">ceph-osd</span></code> 守护进程。</p>
<p>要解决此问题，请确认运行受影响 OSD 的主机上的所有软件包都已正确安装，并且 OSD 守护进程已重启。
如果此问题仍然存在，请检查 OSD 日志，查看有关问题源的信息。</p>
</section>
<section id="bluestore-spurious-read-errors">
<h4>BLUESTORE_SPURIOUS_READ_ERRORS<a class="headerlink" href="#bluestore-spurious-read-errors" title="Permalink to this heading"></a></h4>
<p>至少有一个 BlueStore OSD 在主设备上检测到了读取错误。
BlueStore 已重试磁盘读取，从这些错误中恢复过来了。
该警报可能表明底层硬件有问题、 I/O 子系统有问题、
或类似的问题。此类问题可能导致永久性数据损坏。
有关虚假读取错误根本原因的一些观察结果可在此处找到：
<a class="reference external" href="https://tracker.ceph.com/issues/22464">https://tracker.ceph.com/issues/22464</a> 。</p>
<p>此警报不需要立即响应，但受影响的主机可能需要多加小心：
例如，将主机升级到最新的操作系统/内核版本，
并进行硬件资源利用率监视器。</p>
<p>要在所有 OSD 上禁用此警报，执行下列命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt2">ceph<span class="w"> </span>config<span class="w"> </span><span class="nb">set</span><span class="w"> </span>osd<span class="w"> </span>bluestore_warn_on_spurious_read_errors<span class="w"> </span><span class="nb">false</span></span>
</pre></div></div><p>或者，要在指定 OSD 上禁用此警报，执行下列命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt2">ceph<span class="w"> </span>config<span class="w"> </span><span class="nb">set</span><span class="w"> </span>osd.123<span class="w"> </span>bluestore_warn_on_spurious_read_errors<span class="w"> </span><span class="nb">false</span></span>
</pre></div></div></section>
<section id="block-device-stalled-read-alert">
<h4>BLOCK_DEVICE_STALLED_READ_ALERT<a class="headerlink" href="#block-device-stalled-read-alert" title="Permalink to this heading"></a></h4>
<p>出现了 BlueStore 日志消息，显示存储驱动器问题，
这些问题可能会导致性能下降，并可能导致数据不可用或丢失。
这些信息表明存储驱动器即将出现故障，应进行评估，
而且有可能需要移除并更换。</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">read stalled read 0x29f40370000~100000 (buffered) since 63410177.290546s, timeout is 5.000000s</span>
</pre></div>
</div>
<p>不过，这个很难发现，因为没有明显的警告
（例如， <code class="docutils literal notranslate"><span class="pre">ceph</span> <span class="pre">health</span> <span class="pre">detail</span></code> 中的健康警告或信息）。
更多观察结果请见： <a class="reference external" href="https://tracker.ceph.com/issues/62500">https://tracker.ceph.com/issues/62500</a></p>
<p>还有可能会出现假阳性的 <code class="docutils literal notranslate"><span class="pre">stalled</span> <span class="pre">read</span></code> 实例，因此增加了一个机制来提高准确性。
如果在最近的 <code class="xref std std-confval docutils literal notranslate"><span class="pre">bdev_stalled_read_warn_lifetime</span></code> 秒内，
发现某个 BlueStore 块设备的 <code class="docutils literal notranslate"><span class="pre">stalled</span> <span class="pre">read</span></code> 事件数量大于或等于
<code class="xref std std-confval docutils literal notranslate"><span class="pre">bdev_stalled_read_warn_threshold</span></code> ，就会在 <code class="docutils literal notranslate"><span class="pre">ceph</span> <span class="pre">health</span> <span class="pre">detail</span></code> 中报告此警告。
警告状态将在条件消除后移除。</p>
<p><code class="xref std std-confval docutils literal notranslate"><span class="pre">bdev_stalled_read_warn_lifetime</span></code> 和
<code class="xref std std-confval docutils literal notranslate"><span class="pre">bdev_stalled_read_warn_threshold</span></code> 的默认值可以全局地或对特定 OSD 进行覆盖。</p>
<p>若要更改，执行下列命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1">ceph<span class="w"> </span>config<span class="w"> </span><span class="nb">set</span><span class="w"> </span>global<span class="w"> </span>bdev_stalled_read_warn_lifetime<span class="w"> </span><span class="m">10</span></span>
<span class="prompt1">ceph<span class="w"> </span>config<span class="w"> </span><span class="nb">set</span><span class="w"> </span>global<span class="w"> </span>bdev_stalled_read_warn_threshold<span class="w"> </span><span class="m">5</span></span>
</pre></div></div><p>可以给某些 OSD 或者一个类设置。例如，只给 SSD OSD 设置：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1">ceph<span class="w"> </span>config<span class="w"> </span><span class="nb">set</span><span class="w"> </span>osd.123<span class="w"> </span>bdev_stalled_read_warn_lifetime<span class="w"> </span><span class="m">10</span></span>
<span class="prompt1">ceph<span class="w"> </span>config<span class="w"> </span><span class="nb">set</span><span class="w"> </span>osd.123<span class="w"> </span>bdev_stalled_read_warn_threshold<span class="w"> </span><span class="m">5</span></span>
<span class="prompt1">ceph<span class="w"> </span>config<span class="w"> </span><span class="nb">set</span><span class="w"> </span>class:ssd<span class="w"> </span>bdev_stalled_read_warn_lifetime<span class="w"> </span><span class="m">10</span></span>
<span class="prompt1">ceph<span class="w"> </span>config<span class="w"> </span><span class="nb">set</span><span class="w"> </span>class:ssd<span class="w"> </span>bdev_stalled_read_warn_threshold<span class="w"> </span><span class="m">5</span></span>
</pre></div></div></section>
<section id="wal-device-stalled-read-alert">
<h4>WAL_DEVICE_STALLED_READ_ALERT<a class="headerlink" href="#wal-device-stalled-read-alert" title="Permalink to this heading"></a></h4>
<p>警告状态 <code class="docutils literal notranslate"><span class="pre">WAL_DEVICE_STALLED_READ_ALERT</span></code> 用于指示指定 BlueStore OSD 的
<code class="docutils literal notranslate"><span class="pre">WAL_DEVICE</span></code> 上的 <code class="docutils literal notranslate"><span class="pre">stalled</span> <span class="pre">read</span></code> （读取已停滞）实例。
该警告可通过 <code class="xref std std-confval docutils literal notranslate"><span class="pre">bdev_stalled_read_warn_lifetime</span></code> 和
<code class="xref std std-confval docutils literal notranslate"><span class="pre">bdev_stalled_read_warn_threshold</span></code> 选项进行配置，
配置命令类似于 <code class="docutils literal notranslate"><span class="pre">BLOCK_DEVICE_STALLED_READ_ALERT</span></code> 警告小节所述的命令。</p>
</section>
<section id="db-device-stalled-read-alert">
<h4>DB_DEVICE_STALLED_READ_ALERT<a class="headerlink" href="#db-device-stalled-read-alert" title="Permalink to this heading"></a></h4>
<p>警告状态 <code class="docutils literal notranslate"><span class="pre">DB_DEVICE_STALLED_READ_ALERT</span></code> 用于指示指定 BlueStore OSD 的
<code class="docutils literal notranslate"><span class="pre">DB_DEVICE</span></code> 上的 <code class="docutils literal notranslate"><span class="pre">stalled</span> <span class="pre">read</span></code> （读取已停滞）实例。
该警告可通过 <code class="xref std std-confval docutils literal notranslate"><span class="pre">bdev_stalled_read_warn_lifetime</span></code> 和
<code class="xref std std-confval docutils literal notranslate"><span class="pre">bdev_stalled_read_warn_threshold</span></code> 选项进行配置，
配置命令类似于 <code class="docutils literal notranslate"><span class="pre">BLOCK_DEVICE_STALLED_READ_ALERT</span></code> 警告小节所述的命令。</p>
</section>
<section id="bluestore-slow-op-alert">
<h4>BLUESTORE_SLOW_OP_ALERT<a class="headerlink" href="#bluestore-slow-op-alert" title="Permalink to this heading"></a></h4>
<p>BlueStore 日志信息会显示存储硬盘问题，这些问题可能导致性能下降、
数据不可用或丢失。这些信息表明存储驱动器可能即将发生故障，
应进行检查，有必要的话更换掉。</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">log_latency_fn slow operation observed for _txc_committed_kv, latency = 12.028621219s, txc = 0x55a107c30f00</span>
<span class="go">log_latency_fn slow operation observed for upper_bound, latency = 6.25955s</span>
<span class="go">log_latency slow operation observed for submit_transaction..</span>
</pre></div>
</div>
<p>此情形也可能由 <code class="docutils literal notranslate"><span class="pre">BLUESTORE_SLOW_OP_ALERT</span></code> 集群健康标记反映。</p>
<p>由于可能会出现误报的 <code class="docutils literal notranslate"><span class="pre">slow</span> <span class="pre">ops</span></code> 实例，因此增加了一种机制以提高可靠性。
如果在最近的 <code class="xref std std-confval docutils literal notranslate"><span class="pre">bluestore_slow_ops_warn_lifetime</span></code> 秒内，
发现指定 BlueStore OSD 的 <code class="docutils literal notranslate"><span class="pre">slow</span> <span class="pre">ops</span></code> 指示数量大于或等于 <code class="xref std std-confval docutils literal notranslate"><span class="pre">bluestore_slow_ops_warn_threshold</span></code> ，
就会在 <code class="docutils literal notranslate"><span class="pre">ceph</span> <span class="pre">health</span> <span class="pre">detail</span></code> 中报告该警告。
警告状态会在条件消除后清除。</p>
<p>可以全局地、或更改指定 OSD 的
<code class="xref std std-confval docutils literal notranslate"><span class="pre">bluestore_slow_ops_warn_lifetime</span></code> 和
<code class="xref std std-confval docutils literal notranslate"><span class="pre">bluestore_slow_ops_warn_threshold</span></code> 默认值。</p>
<p>若要更改，执行下列命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1">ceph<span class="w"> </span>config<span class="w"> </span><span class="nb">set</span><span class="w"> </span>global<span class="w"> </span>bluestore_slow_ops_warn_lifetime<span class="w"> </span><span class="m">10</span></span>
<span class="prompt1">ceph<span class="w"> </span>config<span class="w"> </span><span class="nb">set</span><span class="w"> </span>global<span class="w"> </span>bluestore_slow_ops_warn_threshold<span class="w"> </span><span class="m">5</span></span>
</pre></div></div><p>此操作可以针对指定 OSD 或者指定掩码（类别）。例如：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1">ceph<span class="w"> </span>config<span class="w"> </span><span class="nb">set</span><span class="w"> </span>osd.123<span class="w"> </span>bluestore_slow_ops_warn_lifetime<span class="w"> </span><span class="m">10</span></span>
<span class="prompt1">ceph<span class="w"> </span>config<span class="w"> </span><span class="nb">set</span><span class="w"> </span>osd.123<span class="w"> </span>bluestore_slow_ops_warn_threshold<span class="w"> </span><span class="m">5</span></span>
<span class="prompt1">ceph<span class="w"> </span>config<span class="w"> </span><span class="nb">set</span><span class="w"> </span>class:ssd<span class="w"> </span>bluestore_slow_ops_warn_lifetime<span class="w"> </span><span class="m">10</span></span>
<span class="prompt1">ceph<span class="w"> </span>config<span class="w"> </span><span class="nb">set</span><span class="w"> </span>class:ssd<span class="w"> </span>bluestore_slow_ops_warn_threshold<span class="w"> </span><span class="m">5</span></span>
</pre></div></div></section>
</section>
<section id="id6">
<h3>设备健康<a class="headerlink" href="#id6" title="Permalink to this heading"></a></h3>
<section id="device-health">
<h4>DEVICE_HEALTH<a class="headerlink" href="#device-health" title="Permalink to this heading"></a></h4>
<p>预计至少有一个 OSD 设备即将发生故障，
警告阈值由 <code class="docutils literal notranslate"><span class="pre">mgr/devicehealth/warn_threshold</span></code> 配置选项决定。</p>
<p>由于此警报仅适用于当前标记为 <code class="docutils literal notranslate"><span class="pre">in</span></code> 的 OSD ，因此对这种预期故障的恰当响应是：
(1) 标记 OSD 为 <code class="docutils literal notranslate"><span class="pre">out</span></code> ，以便把数据从这个 OSD 迁移出去，
然后 (2) 将硬件从系统中拆除。注意，如果启用了 <code class="docutils literal notranslate"><span class="pre">mgr/devicehealth/self_heal</span></code>
（由 <code class="docutils literal notranslate"><span class="pre">mgr/devicehealth/mark_out_threshold</span></code> 决定），
标记 <code class="docutils literal notranslate"><span class="pre">out</span></code> 这个操作通常会自动完成。如果一个 OSD 设备已经损坏，
但使用着这个设备的 OSD 其状态仍然是 <code class="docutils literal notranslate"><span class="pre">up</span></code> ，那么恢复会降级。
在这种情况下，强制停止有关 OSD 守护进程可能更好，
这样就可以从存活的健康 OSD 开始恢复。
这样做时必须格外小心，注意故障域，以免影响数据可用性。</p>
<p>要检查设备健康状况，执行下列命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1">ceph<span class="w"> </span>device<span class="w"> </span>info<span class="w"> </span>&lt;device-id&gt;</span>
</pre></div></div><p>设备预期寿命用 Ceph 管理器运行的预测模型设置、
或可以执行下列命令的外部工具设置：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1">ceph<span class="w"> </span>device<span class="w"> </span>set-life-expectancy<span class="w"> </span>&lt;device-id&gt;<span class="w"> </span>&lt;from&gt;<span class="w"> </span>&lt;to&gt;</span>
</pre></div></div><p>你可以手动更改已经存储的预期寿命，但这种更改通常不会产生任何效果。
原因在于，最初设置了预期寿命的那个工具，
可能还会再次重设你的更改，
而且更改存储的数值并不会影响硬件设备实际的健康状况。</p>
</section>
<section id="device-health-in-use">
<h4>DEVICE_HEALTH_IN_USE<a class="headerlink" href="#device-health-in-use" title="Permalink to this heading"></a></h4>
<p>至少有一个设备（即 OSD ）预计很快就会发生故障，
并已被标记为 <code class="docutils literal notranslate"><span class="pre">out</span></code> 状态（不在集群内，
由 <code class="docutils literal notranslate"><span class="pre">mgr/devicehealth/mark_out_threshold</span></code> 控制），
但它们仍参与一个或多个归置组。这可能是因为 OSD 最近才被标记为 <code class="docutils literal notranslate"><span class="pre">out</span></code> ，
而数据仍在迁移，也可能是因为某些原因导致数据无法从 OSD 迁出
（例如，集群已经快满了，或 CRUSH 分级结构里没有其他合适的 OSD 可以承接数据）。</p>
<p>要消除此消息，可以禁用自愈行为
（就是把 <code class="docutils literal notranslate"><span class="pre">mgr/devicehealth/self_heal</span></code> 设置为 <code class="docutils literal notranslate"><span class="pre">false</span></code> ）、
调整 <code class="docutils literal notranslate"><span class="pre">mgr/devicehealth/mark_out_threshold</span></code> 、
或找出是什么因素导致数据不能从即将发生故障的 OSD 迁出。</p>
</section>
<section id="device-health-toomany">
<span id="rados-health-checks-device-health-toomany"></span><h4>DEVICE_HEALTH_TOOMANY<a class="headerlink" href="#device-health-toomany" title="Permalink to this heading"></a></h4>
<p>预计有太多设备（即 OSD ）很快将发生故障，
而且由于启用了 <code class="docutils literal notranslate"><span class="pre">mgr/devicehealth/self_heal</span></code> 行为，
把所有嫌疑 OSD 标记为 <code class="docutils literal notranslate"><span class="pre">out</span></code>
会超出集群的 <code class="docutils literal notranslate"><span class="pre">mon_osd_min_in_ratio</span></code> 比率。
此比率可防止过多的 OSD 被自动标记为 <code class="docutils literal notranslate"><span class="pre">out</span></code> 。</p>
<p>你应该及时向集群添加新 OSD 以防止数据丢失，
或逐步替换即将故障的 OSD 。</p>
<p>或者，你可以静默这个健康检查，可以调整选项，
包括 <code class="docutils literal notranslate"><span class="pre">mon_osd_min_in_ratio</span></code> 或 <code class="docutils literal notranslate"><span class="pre">mgr/devicehealth/mark_out_threshold</span></code> 。
但是，特别注意，这将导致不可恢复的数据丢失的可能性增大。</p>
</section>
</section>
<section id="id7">
<h3>数据健康（存储池和归置组们）<a class="headerlink" href="#id7" title="Permalink to this heading"></a></h3>
<section id="pg-availability">
<h4>PG_AVAILABILITY<a class="headerlink" href="#pg-availability" title="Permalink to this heading"></a></h4>
<p>数据可用性降低。换句话说，
集群无法为集群中一部分数据的潜在读取或写入请求提供服务。
更确切地说，至少有一个归置组 (PG) 处于无法为 I/O 请求提供服务的状态。
以下任何一种 PG 状态，如果不能快速清除，都是有问题的：
<em>peering</em> 、 <em>stale</em> 、 <em>incomplete</em> 和 <em>active</em> 缺失。</p>
<p>有关受影响 PG 的详细信息，
执行下列命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1">ceph<span class="w"> </span>health<span class="w"> </span>detail</span>
</pre></div></div><p>大多数情况下，此问题的根源都是当前至少有一个 OSD 处于 <code class="docutils literal notranslate"><span class="pre">down</span></code> 状态：
见前文的 <code class="docutils literal notranslate"><span class="pre">OSD_DOWN</span></code> 。</p>
<p>要查看指定嫌疑 PG 的状态，执行下列命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1">ceph<span class="w"> </span>tell<span class="w"> </span>&lt;pgid&gt;<span class="w"> </span>query</span>
</pre></div></div></section>
<section id="pg-degraded">
<h4>PG_DEGRADED<a class="headerlink" href="#pg-degraded" title="Permalink to this heading"></a></h4>
<p>某些数据的冗余度降低：换句话说，
集群中不是所有数据（在多副本存储池的情况下）
或纠删码片段（在纠删码存储池的情况下）都达到了应有的副本数。
更确切地说，至少有一个归置组 (PG) ：</p>
<ul class="simple">
<li><p>已设置 <em>degraded</em> 或 <em>undersized</em> 标志，
这意味着集群中那个 PG 没有足够的数量；或者</p></li>
<li><p>很长时间都没能达到 <em>clean</em> 状态。</p></li>
</ul>
<p>有关受影响 PG 的详细信息，
执行下列命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1">ceph<span class="w"> </span>health<span class="w"> </span>detail</span>
</pre></div></div><p>大多数情况下，此问题的根源都是当前至少有一个 OSD 处于 <code class="docutils literal notranslate"><span class="pre">down</span></code> 状态：
见前文的 <code class="docutils literal notranslate"><span class="pre">OSD_DOWN</span></code> 。</p>
<p>要查看指定嫌疑 PG 的状态，执行下列命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1">ceph<span class="w"> </span>tell<span class="w"> </span>&lt;pgid&gt;<span class="w"> </span>query</span>
</pre></div></div></section>
<section id="pg-recovery-full">
<h4>PG_RECOVERY_FULL<a class="headerlink" href="#pg-recovery-full" title="Permalink to this heading"></a></h4>
<p>由于集群缺乏可用空间，数据冗余度可能会降低，
甚至使某些数据面临风险。更确切地说，
至少有一个归置组设置了 <em>recovery_toofull</em> 标志，
这意味着集群无法迁移或恢复数据，因为至少有一个 OSD 超过了 <code class="docutils literal notranslate"><span class="pre">full</span></code> 阈值。</p>
<p>有关应对这种情况的步骤，请参阅上文的 <em>OSD_FULL</em> 。</p>
</section>
<section id="pg-backfill-full">
<h4>PG_BACKFILL_FULL<a class="headerlink" href="#pg-backfill-full" title="Permalink to this heading"></a></h4>
<p>由于集群缺乏可用空间，数据冗余度可能会降低，
甚至使某些数据面临风险。更确切地说，
至少有一个归置组设置了 <em>backfill_toofull</em> 标志，
这意味着集群无法迁移或恢复数据，因为至少有一个 OSD 超过了 <code class="docutils literal notranslate"><span class="pre">backfillfull</span></code> 阈值。</p>
<p>有关应对这种情况的步骤，请参阅上文的 <em>OSD_BACKFILLFULL</em> 。</p>
</section>
<section id="pg-damaged">
<h4>PG_DAMAGED<a class="headerlink" href="#pg-damaged" title="Permalink to this heading"></a></h4>
<p>数据洗刷操作发现了集群中存在数据一致性问题。
更确切地说，至少有一个归置组 (1) 已设置 <em>inconsistent</em> 或
<code class="docutils literal notranslate"><span class="pre">snaptrim_error</span></code> 标志，它表明先前的数据洗刷操作发现了问题，
或 (2) 已设置 <em>repair</em> 标志，这意味着当前正在对这样的不一致进行修复。</p>
<p>详情见 <a class="reference internal" href="../../troubleshooting/troubleshooting-pg/"><span class="doc">归置组排障</span></a> 。</p>
</section>
<section id="osd-scrub-errors">
<h4>OSD_SCRUB_ERRORS<a class="headerlink" href="#osd-scrub-errors" title="Permalink to this heading"></a></h4>
<p>近期的 OSD 洗刷出现了明显不一致的地方。这个错误一般和
<em>PG_DAMAGED</em> （见上文）成对出现。</p>
<p>详情见 <a class="reference internal" href="../../troubleshooting/troubleshooting-pg/"><span class="doc">归置组排障</span></a> 。</p>
</section>
<section id="osd-too-many-repairs">
<h4>OSD_TOO_MANY_REPAIRS<a class="headerlink" href="#osd-too-many-repairs" title="Permalink to this heading"></a></h4>
<p>读修复次数已超过配置的阈值数值
<code class="docutils literal notranslate"><span class="pre">mon_osd_warn_num_repaired</span></code> （默认值： <code class="docutils literal notranslate"><span class="pre">10</span></code> ）。
由于洗刷操作只处理静态数据的错误，
而且当另一个副本可用时发生的任何读取错误都会立即修复，
客户端也可以获取到对象数据，
有可能存在即将发生故障的磁盘，它们没有注册任何洗刷错误。
这个修复计数的存在就是为了识别此类故障磁盘。</p>
<p>为了清除此警告，我们加了一条新命令
<code class="docutils literal notranslate"><span class="pre">ceph</span> <span class="pre">tell</span> <span class="pre">osd.#</span> <span class="pre">clear_shards_repaired</span> <span class="pre">[count]</span></code> 。
默认情况下，它会将修复计数设为 0 。可以给此命令加 <cite>count</cite> 数值。
这样，管理员就可以向命令传递 <code class="docutils literal notranslate"><span class="pre">mon_osd_warn_num_repaired</span></code>
（或提高）的数值来重新启用这条警告。
除了用 <cite>clear_shards_repaired</cite> 之外，还可以用
<cite>ceph health mute</cite> 来给 <cite>OSD_TOO_MANY_REPAIRS</cite> 警报静音。</p>
</section>
<section id="large-omap-objects">
<h4>LARGE_OMAP_OBJECTS<a class="headerlink" href="#large-omap-objects" title="Permalink to this heading"></a></h4>
<p>至少有一个存储池包含巨型 omap 对象，由
<code class="docutils literal notranslate"><span class="pre">osd_deep_scrub_large_omap_object_key_threshold</span></code> （用于确定大型 omap 对象的键数阈值）
或 <code class="docutils literal notranslate"><span class="pre">osd_deep_scrub_large_omap_object_value_sum_threshold</span></code>
（用于确定是否为大型 omap 对象的所有键值总字节数的阈值）或两者决定。
要查找有关对象名称、键值数和字节数的更多信息，
请在群集日志中搜索 “Large omap object found”（发现大型 omap 对象）。
未启用自动重分片的 RGW-Bucket 索引对象可能会导致此问题。
有关重分片的更多信息，请参阅
<a class="reference internal" href="../../../radosgw/dynamicresharding/#rgw-dynamic-bucket-index-resharding"><span class="std std-ref">RGW Dynamic Bucket Index Resharding</span></a> 。</p>
<p>要调整上述阈值，执行下列命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1">ceph<span class="w"> </span>config<span class="w"> </span><span class="nb">set</span><span class="w"> </span>osd<span class="w"> </span>osd_deep_scrub_large_omap_object_key_threshold<span class="w"> </span>&lt;keys&gt;</span>
<span class="prompt1">ceph<span class="w"> </span>config<span class="w"> </span><span class="nb">set</span><span class="w"> </span>osd<span class="w"> </span>osd_deep_scrub_large_omap_object_value_sum_threshold<span class="w"> </span>&lt;bytes&gt;</span>
</pre></div></div></section>
<section id="cache-pool-near-full">
<h4>CACHE_POOL_NEAR_FULL<a class="headerlink" href="#cache-pool-near-full" title="Permalink to this heading"></a></h4>
<p>缓存层存储池即将填满，该状态由缓存池的 <code class="docutils literal notranslate"><span class="pre">target_max_bytes</span></code> 和
<code class="docutils literal notranslate"><span class="pre">target_max_objects</span></code> 属性决定。当存储池达到目标阈值时，
此存储池的写入请求可能阻塞，同时，缓存中的数据会被刷回和驱逐。
此状态通常会导致极高的延迟和性能下降。</p>
<p>要调整缓存存储池的目标尺寸，执行下列命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1">ceph<span class="w"> </span>osd<span class="w"> </span>pool<span class="w"> </span><span class="nb">set</span><span class="w"> </span>&lt;cache-pool-name&gt;<span class="w"> </span>target_max_bytes<span class="w"> </span>&lt;bytes&gt;</span>
<span class="prompt1">ceph<span class="w"> </span>osd<span class="w"> </span>pool<span class="w"> </span><span class="nb">set</span><span class="w"> </span>&lt;cache-pool-name&gt;<span class="w"> </span>target_max_objects<span class="w"> </span>&lt;objects&gt;</span>
</pre></div></div><p>正常的缓存刷回和驱逐活动被抑制可能还有其他原因：例如，
基础层（ base tier ）可用性降低、基础层性能下降或集群整体负载过高。</p>
</section>
<section id="too-few-pgs">
<h4>TOO_FEW_PGS<a class="headerlink" href="#too-few-pgs" title="Permalink to this heading"></a></h4>
<p>集群中正在使用的归置组（PG）数量低于可配置阈值，
每个 OSD 最少 <code class="docutils literal notranslate"><span class="pre">mon_pg_warn_min_per_osd</span></code> 个 PG 。
这可能导致数据在集群 OSD 间分布不均、
平衡性不足，进而降低整体性能。</p>
<p>如果数据存储池尚未创建，此情况属正常现象。</p>
<p>要解决此问题，可增加现有数据池的 PG 数量或创建新存储池。
更多信息请参阅 <a class="reference internal" href="../placement-groups/#choosing-number-of-placement-groups"><span class="std std-ref">确定 PG 数量</span></a> 。</p>
</section>
<section id="pool-pg-num-not-power-of-two">
<h4>POOL_PG_NUM_NOT_POWER_OF_TWO<a class="headerlink" href="#pool-pg-num-not-power-of-two" title="Permalink to this heading"></a></h4>
<p>至少有一个存储池的 <code class="docutils literal notranslate"><span class="pre">pg_num</span></code> 值不是 2 的幂次方。虽然这不是致命错误，
但会造成数据分布失衡——某些归置组将承载远超其他组的数据量。</p>
<p>此问题可轻松纠正，把受影响存储池的 <code class="docutils literal notranslate"><span class="pre">pg_num</span></code> 值调整为最接近的 2 的幂次方即可。
可以启用 PG Autoscaler ，或执行如下命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1">ceph<span class="w"> </span>osd<span class="w"> </span>pool<span class="w"> </span><span class="nb">set</span><span class="w"> </span>&lt;pool-name&gt;<span class="w"> </span>pg_num<span class="w"> </span>&lt;value&gt;</span>
</pre></div></div><p>要禁用此健康检查，执行下列命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1">ceph<span class="w"> </span>config<span class="w"> </span><span class="nb">set</span><span class="w"> </span>global<span class="w"> </span>mon_warn_on_pool_pg_num_not_power_of_two<span class="w"> </span><span class="nb">false</span></span>
</pre></div></div><p>注意，不建议禁用此健康检查。</p>
</section>
<section id="pool-too-few-pgs">
<h4>POOL_TOO_FEW_PGS<a class="headerlink" href="#pool-too-few-pgs" title="Permalink to this heading"></a></h4>
<p>鉴于当前存储在存储池中的数据量，
一个或多个存储池可能需要更多归置组（ PG ）。
此问题可能导致集群中 OSD 的数据分布和平衡性不佳，从而降低整体性能。
只有当存储池的 <code class="docutils literal notranslate"><span class="pre">pg_autoscale_mode</span></code> 属性设置为 <code class="docutils literal notranslate"><span class="pre">warn</span></code> 时才会触发此警报。</p>
<p>如果要禁用此警报，可执行以下命令，
完全禁用该存储池的 PG 自动伸缩功能：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1">ceph<span class="w"> </span>osd<span class="w"> </span>pool<span class="w"> </span><span class="nb">set</span><span class="w"> </span>&lt;pool-name&gt;<span class="w"> </span>pg_autoscale_mode<span class="w"> </span>off</span>
</pre></div></div><p>要允许集群自动调整存储池的 PG 数量，
执行下列命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1">ceph<span class="w"> </span>osd<span class="w"> </span>pool<span class="w"> </span><span class="nb">set</span><span class="w"> </span>&lt;pool-name&gt;<span class="w"> </span>pg_autoscale_mode<span class="w"> </span>on</span>
</pre></div></div><p>另外，要想手动把一个存储池的 PG 数量设置成建议的数值，
执行下列命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1">ceph<span class="w"> </span>osd<span class="w"> </span>pool<span class="w"> </span><span class="nb">set</span><span class="w"> </span>&lt;pool-name&gt;<span class="w"> </span>pg_num<span class="w"> </span>&lt;new-pg-num&gt;</span>
</pre></div></div><p>详情见 <a class="reference internal" href="../placement-groups/#choosing-number-of-placement-groups"><span class="std std-ref">确定 PG 数量</span></a> 和
<a class="reference internal" href="../placement-groups/#pg-autoscaler"><span class="std std-ref">自动伸缩归置组</span></a> 。</p>
</section>
<section id="too-many-pgs">
<h4>TOO_MANY_PGS<a class="headerlink" href="#too-many-pgs" title="Permalink to this heading"></a></h4>
<p>集群中在用的归置组（ PG ）数量已超过可配置的阈值：
每 OSD <code class="docutils literal notranslate"><span class="pre">mon_max_pg_per_osd</span></code> 个 PG 。
若超过此阈值，集群会禁止新建存储池、增加池 <cite>pg_num</cite> 数量或提高存储池的副本数
（上述任一操作均会导致集群 PG 数量增加）。
过多的 PG 会导致 OSD 守护进程的内存占用率升高，
集群状态变更后（如 OSD 重启、新增或移除）的互联速度变慢，
并增加管理器和监视器守护进程的负载。</p>
<p>要缓解此问题，最简单的方案是新增硬件来提升集群中 OSD 节点的数量。
注意：由于本健康检查统计的是处于 <code class="docutils literal notranslate"><span class="pre">in</span></code> 状态的 OSD 节点数量，
如果有可用的 <code class="docutils literal notranslate"><span class="pre">out</span></code> OSD 节点，把它们标记为 <code class="docutils literal notranslate"><span class="pre">in</span></code> 同样有效。
真要标记的话，执行下列命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1">ceph<span class="w"> </span>osd<span class="w"> </span><span class="k">in</span><span class="w"> </span>&lt;osd<span class="w"> </span>id<span class="o">(</span>s<span class="o">)</span>&gt;</span>
</pre></div></div><p>详情见 <a class="reference internal" href="../placement-groups/#choosing-number-of-placement-groups"><span class="std std-ref">确定 PG 数量</span></a> 。</p>
</section>
<section id="pool-too-many-pgs">
<h4>POOL_TOO_MANY_PGS<a class="headerlink" href="#pool-too-many-pgs" title="Permalink to this heading"></a></h4>
<p>鉴于当前存储在存储池中的数据量，
一个或多个存储池应减少其归置组（PG）数量。
此问题可能导致 OSD 守护进程内存利用率偏高、
集群状态变更后（例如 OSD 重启、新增或移除）互联速度变慢，
以及管理器和监视器守护进程负载增加。
只有当存储池的 <code class="docutils literal notranslate"><span class="pre">pg_autoscale_mode</span></code> 属性设置为 <code class="docutils literal notranslate"><span class="pre">warn</span></code> 时才会触发此警报。</p>
<p>要禁用该警报，可以完全关闭存储池的 PG 自动伸缩功能，
执行下列命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1">ceph<span class="w"> </span>osd<span class="w"> </span>pool<span class="w"> </span><span class="nb">set</span><span class="w"> </span>&lt;pool-name&gt;<span class="w"> </span>pg_autoscale_mode<span class="w"> </span>off</span>
</pre></div></div><p>要允许集群自动调整某个存储池的 PG 数量，
执行下列命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1">ceph<span class="w"> </span>osd<span class="w"> </span>pool<span class="w"> </span><span class="nb">set</span><span class="w"> </span>&lt;pool-name&gt;<span class="w"> </span>pg_autoscale_mode<span class="w"> </span>on</span>
</pre></div></div><p>另外，可以手动把某个存储池的 PG 数设置为建议值，
执行下列命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1">ceph<span class="w"> </span>osd<span class="w"> </span>pool<span class="w"> </span><span class="nb">set</span><span class="w"> </span>&lt;pool-name&gt;<span class="w"> </span>pg_num<span class="w"> </span>&lt;new-pg-num&gt;</span>
</pre></div></div><p>详情见 <a class="reference internal" href="../placement-groups/#choosing-number-of-placement-groups"><span class="std std-ref">确定 PG 数量</span></a> 和
<a class="reference internal" href="../placement-groups/#pg-autoscaler"><span class="std std-ref">自动伸缩归置组</span></a> 。</p>
</section>
<section id="pool-target-size-bytes-overcommitted">
<h4>POOL_TARGET_SIZE_BYTES_OVERCOMMITTED<a class="headerlink" href="#pool-target-size-bytes-overcommitted" title="Permalink to this heading"></a></h4>
<p>至少有一个存储池明确设置了 <code class="docutils literal notranslate"><span class="pre">target_size_bytes</span></code> 属性，
用于估算存储池的预期大小，
但该属性的值（单独或与其他存储池组合）超过了总的可用存储空间。</p>
<p>此警报通常表明存储池的 <code class="docutils literal notranslate"><span class="pre">target_size_bytes</span></code> 值过于大了，
应该减小或设为零。要减小 <code class="docutils literal notranslate"><span class="pre">target_size_bytes</span></code> 数值或将其设为零，
执行下列命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1">ceph<span class="w"> </span>osd<span class="w"> </span>pool<span class="w"> </span><span class="nb">set</span><span class="w"> </span>&lt;pool-name&gt;<span class="w"> </span>target_size_bytes<span class="w"> </span><span class="m">0</span></span>
</pre></div></div><p>上述命令把 <code class="docutils literal notranslate"><span class="pre">target_size_bytes</span></code> 的数值设置成了 0 。
要把 <code class="docutils literal notranslate"><span class="pre">target_size_bytes</span></code> 的数值设置成非 0 的值，
把 <code class="docutils literal notranslate"><span class="pre">0</span></code> 换成你想要的非 0 数值即可。</p>
<p>更详细的内容见  <a class="reference internal" href="../placement-groups/#specifying-pool-target-size"><span class="std std-ref">配置期望的存储池尺寸</span></a> 。</p>
</section>
<section id="pool-has-target-size-bytes-and-ratio">
<h4>POOL_HAS_TARGET_SIZE_BYTES_AND_RATIO<a class="headerlink" href="#pool-has-target-size-bytes-and-ratio" title="Permalink to this heading"></a></h4>
<p>至少有一个存储池同时设置了 <code class="docutils literal notranslate"><span class="pre">target_size_bytes</span></code> 和
<code class="docutils literal notranslate"><span class="pre">target_size_ratio</span></code> 属性时，系统将据此估算存储池的预期大小。
这两个属性中仅允许一个是非零值。若两者均设置为非零值，
则优先采用 <code class="docutils literal notranslate"><span class="pre">target_size_ratio</span></code> ，忽略 <code class="docutils literal notranslate"><span class="pre">target_size_bytes</span></code> 。</p>
<p>要把 <code class="docutils literal notranslate"><span class="pre">target_size_bytes</span></code> 重置为 0 ，执行下列命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1">ceph<span class="w"> </span>osd<span class="w"> </span>pool<span class="w"> </span><span class="nb">set</span><span class="w"> </span>&lt;pool-name&gt;<span class="w"> </span>target_size_bytes<span class="w"> </span><span class="m">0</span></span>
</pre></div></div><p>详情见 <a class="reference internal" href="../placement-groups/#specifying-pool-target-size"><span class="std std-ref">配置期望的存储池尺寸</span></a> 。</p>
</section>
<section id="too-few-osds">
<h4>TOO_FEW_OSDS<a class="headerlink" href="#too-few-osds" title="Permalink to this heading"></a></h4>
<p>集群中的 OSD 数量低于可配置阈值 <code class="docutils literal notranslate"><span class="pre">osd_pool_default_size</span></code> 。
这意味着部分或全部数据可能无法满足 CRUSH 规则和存储池配置中指定的数据保护策略。</p>
</section>
<section id="smaller-pgp-num">
<h4>SMALLER_PGP_NUM<a class="headerlink" href="#smaller-pgp-num" title="Permalink to this heading"></a></h4>
<p>至少有一个存储池的 <code class="docutils literal notranslate"><span class="pre">pgp_num</span></code> 数值小于 <code class="docutils literal notranslate"><span class="pre">pg_num</span></code> 。
此警报通常表明在归置行为没有增加的情况下，
归置组（ PG ）计数被增加了。</p>
<p>这种差异有时是有意引进的，目的是分离出 <cite>split</cite> 步骤，
因为在 <code class="docutils literal notranslate"><span class="pre">pgp_num</span></code> 更改后，会引起数据迁移，
进而导致 PG 计数被调整。</p>
<p>解决此问题的方法，通常是把 <code class="docutils literal notranslate"><span class="pre">pgp_num</span></code> 设置为与 <code class="docutils literal notranslate"><span class="pre">pg_num</span></code> 相匹配的数值，
从而触发数据迁移。执行下列命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1">ceph<span class="w"> </span>osd<span class="w"> </span>pool<span class="w"> </span><span class="nb">set</span><span class="w"> </span>&lt;pool&gt;<span class="w"> </span>pgp_num<span class="w"> </span>&lt;pg-num-value&gt;</span>
</pre></div></div></section>
<section id="many-objects-per-pg">
<h4>MANY_OBJECTS_PER_PG<a class="headerlink" href="#many-objects-per-pg" title="Permalink to this heading"></a></h4>
<p>至少有一个存储池里每个归置组（ PG ）的平均对象数量远高于整个集群的平均值。
具体的阈值由 <code class="docutils literal notranslate"><span class="pre">mon_pg_warn_max_object_skew</span></code> 配置值决定。</p>
<p>此警报通常表明：包含集群大部分数据的存储池，
它的 PG 数量过少，或者是数据较少的其他存储池它们的 PG 数量过多。
见上文 <em>TOO_MANY_PGS</em> 。</p>
<p>在管理器上调高 <code class="docutils literal notranslate"><span class="pre">mon_pg_warn_max_object_skew</span></code> 配置选项的阈值可以消除此健康告警。</p>
<p>对于某个指定存储池，如果把 <code class="docutils literal notranslate"><span class="pre">pg_autoscale_mode</span></code> 设置为 <code class="docutils literal notranslate"><span class="pre">on</span></code> ，
它的健康告警就能消除。</p>
</section>
<section id="pool-app-not-enabled">
<h4>POOL_APP_NOT_ENABLED<a class="headerlink" href="#pool-app-not-enabled" title="Permalink to this heading"></a></h4>
<p>一个存储池存在，但是这个存储池没打标签，标记它用于哪个应用程序。</p>
<p>要解决此问题，给这个存储池打个标签用于一个应用程序即可。
例如，如果此存储池用于 RBD ，执行下列命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1">rbd<span class="w"> </span>pool<span class="w"> </span>init<span class="w"> </span>&lt;poolname&gt;</span>
</pre></div></div><p>另外，如果这个存储池在被一个定制应用程序使用（这里是 foo ），
你可以执行下面的低级命令来给存储池打标：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1">ceph<span class="w"> </span>osd<span class="w"> </span>pool<span class="w"> </span>application<span class="w"> </span><span class="nb">enable</span><span class="w"> </span>foo</span>
</pre></div></div><p>详情见  <a class="reference internal" href="../pools/#associate-pool-to-application"><span class="std std-ref">关联存储池与应用程序</span></a> 。</p>
</section>
<section id="id8">
<h4>POOL_FULL<a class="headerlink" href="#id8" title="Permalink to this heading"></a></h4>
<p>至少有一个存储池已达到（或即将达到）其配额上限。
触发此健康检查的阈值由 <code class="docutils literal notranslate"><span class="pre">mon_pool_quota_crit_threshold</span></code> 配置选项决定。</p>
<p>可通过执行下列命令来调高或调低（或去除）存储池配额：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1">ceph<span class="w"> </span>osd<span class="w"> </span>pool<span class="w"> </span>set-quota<span class="w"> </span>&lt;pool&gt;<span class="w"> </span>max_bytes<span class="w"> </span>&lt;bytes&gt;</span>
<span class="prompt1">ceph<span class="w"> </span>osd<span class="w"> </span>pool<span class="w"> </span>set-quota<span class="w"> </span>&lt;pool&gt;<span class="w"> </span>max_objects<span class="w"> </span>&lt;objects&gt;</span>
</pre></div></div><p>要禁用配额，可以把配额数值设置为 <code class="docutils literal notranslate"><span class="pre">0</span></code> 。</p>
</section>
<section id="pool-near-full">
<h4>POOL_NEAR_FULL<a class="headerlink" href="#pool-near-full" title="Permalink to this heading"></a></h4>
<p>至少有一个存储池即将达到配置的用满阈值。</p>
<p>有好几个阈值能触发此健康检查，其中之一由
<code class="docutils literal notranslate"><span class="pre">mon_pool_quota_warn_threshold</span></code> 配置选项决定。</p>
<p>可通过执行下列命令来调高或调低（或去除）存储池配额：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1">ceph<span class="w"> </span>osd<span class="w"> </span>pool<span class="w"> </span>set-quota<span class="w"> </span>&lt;pool&gt;<span class="w"> </span>max_bytes<span class="w"> </span>&lt;bytes&gt;</span>
<span class="prompt1">ceph<span class="w"> </span>osd<span class="w"> </span>pool<span class="w"> </span>set-quota<span class="w"> </span>&lt;pool&gt;<span class="w"> </span>max_objects<span class="w"> </span>&lt;objects&gt;</span>
</pre></div></div><p>要禁用配额，可以把配额数值设置为 0 。</p>
<p>能触发上述两个健康检查的其它阈值有
<code class="docutils literal notranslate"><span class="pre">mon_osd_nearfull_ratio</span></code> 和 <code class="docutils literal notranslate"><span class="pre">mon_osd_full_ratio</span></code> 。
细节及解决方法见 <a class="reference internal" href="../../configuration/mon-config-ref/#storage-capacity"><span class="std std-ref">存储容量</span></a> 和 <a class="reference internal" href="../../troubleshooting/troubleshooting-osd/#no-free-drive-space"><span class="std std-ref">硬盘没剩余空间</span></a> 。</p>
</section>
<section id="object-misplaced">
<h4>OBJECT_MISPLACED<a class="headerlink" href="#object-misplaced" title="Permalink to this heading"></a></h4>
<p>集群内一个或多个对象未存储在 CRUSH 算法推荐的位置。
此警报表明，近期集群变更引发的数据迁移尚未完成。</p>
<p>数据归置错误本身并非危险状态；数据一致性从未有风险，
并且新副本都创建好且数量达到期望值、位于期望的位置之前，
旧对象副本不会被清除。</p>
</section>
<section id="object-unfound">
<h4>OBJECT_UNFOUND<a class="headerlink" href="#object-unfound" title="Permalink to this heading"></a></h4>
<p>集群内至少有一个对象找不到。更准确地说，
OSD 们都知道一个对象的较新或更新后的副本应该存在，
但是从目前在线的 OSD 上却找不到这个对象副本。</p>
<p>对未找到对象的读出或写入请求会阻塞。</p>
<p>理想情况下，持有未找到对象较新副本的 “down” OSD 能够重新上线。
要识别候选 OSD ，需检查负责这个未找到对象的 PG(s) 互联状态。
要查看互联状态，执行下列命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1">ceph<span class="w"> </span>tell<span class="w"> </span>&lt;pgid&gt;<span class="w"> </span>query</span>
</pre></div></div><p>另一方面，如果对象的最新副本不可用，
可以让集群回滚到该对象的先前版本。
详情见 <a class="reference internal" href="../../troubleshooting/troubleshooting-pg/#failures-osd-unfound"><span class="std std-ref">未找到的对象</span></a> 。</p>
</section>
<section id="slow-ops">
<h4>SLOW_OPS<a class="headerlink" href="#slow-ops" title="Permalink to this heading"></a></h4>
<p>至少有一个 OSD 请求或监视器请求在处理时花费的时间过长。
此警报可能表明系统负载过高、存储设备速度缓慢或存在软件缺陷。</p>
<p>要向守护进程查询导致速度缓慢的请求队列，
在这个守护进程所在主机上运行以下命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1">ceph<span class="w"> </span>daemon<span class="w"> </span>osd.&lt;id&gt;<span class="w"> </span>ops</span>
</pre></div></div><p>要查看最慢的近期请求的梗概，执行下列命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1">ceph<span class="w"> </span>daemon<span class="w"> </span>osd.&lt;id&gt;<span class="w"> </span>dump_historic_ops</span>
</pre></div></div><p>要查看某一 OSD 的位置，执行下列命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1">ceph<span class="w"> </span>osd<span class="w"> </span>find<span class="w"> </span>osd.&lt;id&gt;</span>
</pre></div></div></section>
<section id="pg-not-scrubbed">
<h4>PG_NOT_SCRUBBED<a class="headerlink" href="#pg-not-scrubbed" title="Permalink to this heading"></a></h4>
<p>至少有一个归置组（ PG ）最近没有进行进行洗刷。
PG 通常会在由全局变量 <a class="reference internal" href="../../configuration/osd-config-ref/#confval-osd_scrub_max_interval"><code class="xref std std-confval docutils literal notranslate"><span class="pre">osd_scrub_max_interval</span></code></a>
确定的时间间隔内进行洗刷。
这个间隔可通过修改存储池的变量 <code class="xref std std-confval docutils literal notranslate"><span class="pre">scrub_max_interval</span></code> 的值覆盖掉。
当洗刷计划发起后，若超过设定的时间间隔百分比
（由 <code class="docutils literal notranslate"><span class="pre">mon_warn_pg_not_scrubbed_ratio</span></code> 决定），
却仍未执行洗刷，就触发此健康检查。</p>
<p>只有在 PG 被标记为 <code class="docutils literal notranslate"><span class="pre">clean</span></code> （意思是它们将是干净的，
而不是说它们已经被检查过、发现是干净的）时才会被洗刷。
归置错的或降级的 PG 不会被标记为 <code class="docutils literal notranslate"><span class="pre">clean</span></code>
（参见上文 <em>PG_AVAILABILITY</em> 和 <em>PG_DEGRADED</em> ）。</p>
<p>如果需要手动对干净 PG 进行洗刷，执行下列命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1">ceph<span class="w"> </span>pg<span class="w"> </span>scrub<span class="w"> </span>&lt;pgid&gt;</span>
</pre></div></div></section>
<section id="pg-not-deep-scrubbed">
<h4>PG_NOT_DEEP_SCRUBBED<a class="headerlink" href="#pg-not-deep-scrubbed" title="Permalink to this heading"></a></h4>
<p>一个或多个归置组（ PG ）近期未进行深度洗刷。
PG 通常每隔最多 <a class="reference internal" href="../../configuration/osd-config-ref/#confval-osd_deep_scrub_interval"><code class="xref std std-confval docutils literal notranslate"><span class="pre">osd_deep_scrub_interval</span></code></a> 秒进行一次洗刷。
当洗刷计划发起后，时间间隔超过
<code class="xref std std-confval docutils literal notranslate"><span class="pre">mon_warn_pg_not_deep_scrubbed_ratio</span></code> 比例仍未执行洗刷时，
就会触发此健康检查告警。</p>
<p>只有当 PG 被标记为 <code class="docutils literal notranslate"><span class="pre">clean</span></code> （意思是它们将是干净的，
而不是说它们已经被检查过、发现是干净的）时才会被深度洗刷。
归置错误或降级的 PG 可能不会被标记为 <code class="docutils literal notranslate"><span class="pre">clean</span></code>
（参见上文 <em>PG_AVAILABILITY</em> 和 <em>PG_DEGRADED</em> ）。</p>
<p>本文档提供两种设置 <a class="reference internal" href="../../configuration/osd-config-ref/#confval-osd_deep_scrub_interval"><code class="xref std std-confval docutils literal notranslate"><span class="pre">osd_deep_scrub_interval</span></code></a> 数值的方法。
第一种方法能够全局更改 <a class="reference internal" href="../../configuration/osd-config-ref/#confval-osd_deep_scrub_interval"><code class="xref std std-confval docutils literal notranslate"><span class="pre">osd_deep_scrub_interval</span></code></a> 的数值，
第二种方法则分别更改 OSD 和管理器守护进程的
<a class="reference internal" href="../../configuration/osd-config-ref/#confval-osd_deep_scrub_interval"><code class="xref std std-confval docutils literal notranslate"><span class="pre">osd_deep_scrub_interval</span></code></a> 数值。</p>
<section id="id9">
<h5>方法一<a class="headerlink" href="#id9" title="Permalink to this heading"></a></h5>
<p>要手动发起对一个干净 PG 的深度洗刷，执行下列命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1">ceph<span class="w"> </span>pg<span class="w"> </span>deep-scrub<span class="w"> </span>&lt;pgid&gt;</span>
</pre></div></div><p>在特定条件下，会出现警告信息 <code class="docutils literal notranslate"><span class="pre">PGs</span> <span class="pre">not</span> <span class="pre">deep-scrubbed</span> <span class="pre">in</span> <span class="pre">time</span></code>
（PG 未及时深度洗刷）。这可能是因为集群中包含很多大型 PG ，
其深度洗刷过程耗时较长。为解决此问题，
必须更改全局的 <a class="reference internal" href="../../configuration/osd-config-ref/#confval-osd_deep_scrub_interval"><code class="xref std std-confval docutils literal notranslate"><span class="pre">osd_deep_scrub_interval</span></code></a> 数值。</p>
<ol class="arabic">
<li><p>确认 <code class="docutils literal notranslate"><span class="pre">ceph</span> <span class="pre">health</span> <span class="pre">detail</span></code> 返回了 <code class="docutils literal notranslate"><span class="pre">pgs</span> <span class="pre">not</span> <span class="pre">deep-scrubbed</span> <span class="pre">in</span> <span class="pre">time</span></code>
警告信息:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># ceph health detail</span>
<span class="n">HEALTH_WARN</span> <span class="mi">1161</span> <span class="n">pgs</span> <span class="ow">not</span> <span class="n">deep</span><span class="o">-</span><span class="n">scrubbed</span> <span class="ow">in</span> <span class="n">time</span>
<span class="p">[</span><span class="n">WRN</span><span class="p">]</span> <span class="n">PG_NOT_DEEP_SCRUBBED</span><span class="p">:</span> <span class="mi">1161</span> <span class="n">pgs</span> <span class="ow">not</span> <span class="n">deep</span><span class="o">-</span><span class="n">scrubbed</span> <span class="ow">in</span> <span class="n">time</span>
<span class="n">pg</span> <span class="mf">86.</span><span class="n">fff</span> <span class="ow">not</span> <span class="n">deep</span><span class="o">-</span><span class="n">scrubbed</span> <span class="n">since</span> <span class="mi">2024</span><span class="o">-</span><span class="mi">08</span><span class="o">-</span><span class="mi">21</span><span class="n">T02</span><span class="p">:</span><span class="mi">35</span><span class="p">:</span><span class="mf">25.733187</span><span class="o">+</span><span class="mi">0000</span>
</pre></div>
</div>
</li>
<li><p>更改全局的 <code class="docutils literal notranslate"><span class="pre">osd_deep_scrub_interval</span></code> ：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt2">ceph<span class="w"> </span>config<span class="w"> </span><span class="nb">set</span><span class="w"> </span>global<span class="w"> </span>osd_deep_scrub_interval<span class="w"> </span><span class="m">1209600</span></span>
</pre></div></div></li>
</ol>
<p>上述步骤是 Eugen Block 在 2024 年 9 月开发的。</p>
<p>细节见 <a class="reference external" href="https://heiterbiswolkig.blogs.nde.ag/2024/09/06/pgs-not-deep-scrubbed-in-time/">Eugen Block 的博客</a> 。</p>
<p>见 <a class="reference external" href="https://tracker.ceph.com/issues/44959">Redmine tracker issue #44959</a> 。</p>
</section>
<section id="id10">
<h5>方法二<a class="headerlink" href="#id10" title="Permalink to this heading"></a></h5>
<p>要对一个干净的 PG 手动启动深度洗刷，执行下列命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1">ceph<span class="w"> </span>pg<span class="w"> </span>deep-scrub<span class="w"> </span>&lt;pgid&gt;</span>
</pre></div></div><p>在特定情况下，会出现 <code class="docutils literal notranslate"><span class="pre">PGs</span> <span class="pre">not</span> <span class="pre">deep-scrubbed</span> <span class="pre">in</span> <span class="pre">time</span></code> 警告信息。
可能是因为此集群包含很多大型 PG ，它们需要较长的时间才能完成深度洗刷。
要应对此情形，必须更改 OSD 和管理器守护进程的
<a class="reference internal" href="../../configuration/osd-config-ref/#confval-osd_deep_scrub_interval"><code class="xref std std-confval docutils literal notranslate"><span class="pre">osd_deep_scrub_interval</span></code></a> 数值。</p>
<ol class="arabic">
<li><p>确认 <code class="docutils literal notranslate"><span class="pre">ceph</span> <span class="pre">health</span> <span class="pre">detail</span></code> 会返回 <code class="docutils literal notranslate"><span class="pre">pgs</span> <span class="pre">not</span> <span class="pre">deep-scrubbed</span> <span class="pre">in</span> <span class="pre">time</span></code>
警告信息:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># ceph health detail</span>
<span class="n">HEALTH_WARN</span> <span class="mi">1161</span> <span class="n">pgs</span> <span class="ow">not</span> <span class="n">deep</span><span class="o">-</span><span class="n">scrubbed</span> <span class="ow">in</span> <span class="n">time</span>
<span class="p">[</span><span class="n">WRN</span><span class="p">]</span> <span class="n">PG_NOT_DEEP_SCRUBBED</span><span class="p">:</span> <span class="mi">1161</span> <span class="n">pgs</span> <span class="ow">not</span> <span class="n">deep</span><span class="o">-</span><span class="n">scrubbed</span> <span class="ow">in</span> <span class="n">time</span>
<span class="n">pg</span> <span class="mf">86.</span><span class="n">fff</span> <span class="ow">not</span> <span class="n">deep</span><span class="o">-</span><span class="n">scrubbed</span> <span class="n">since</span> <span class="mi">2024</span><span class="o">-</span><span class="mi">08</span><span class="o">-</span><span class="mi">21</span><span class="n">T02</span><span class="p">:</span><span class="mi">35</span><span class="p">:</span><span class="mf">25.733187</span><span class="o">+</span><span class="mi">0000</span>
</pre></div>
</div>
</li>
<li><p>更改 OSD 的 <code class="docutils literal notranslate"><span class="pre">osd_deep_scrub_interval</span></code> ：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt2">ceph<span class="w"> </span>config<span class="w"> </span><span class="nb">set</span><span class="w"> </span>osd<span class="w"> </span>osd_deep_scrub_interval<span class="w"> </span><span class="m">1209600</span></span>
</pre></div></div></li>
<li><p>更改管理器的 <code class="docutils literal notranslate"><span class="pre">osd_deep_scrub_interval</span></code> ：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt2">ceph<span class="w"> </span>config<span class="w"> </span><span class="nb">set</span><span class="w"> </span>mgr<span class="w"> </span>osd_deep_scrub_interval<span class="w"> </span><span class="m">1209600</span></span>
</pre></div></div></li>
</ol>
<p>上述步骤是 Eugen Block 在 2024 年 9 月份开发的。</p>
<p>细节见 <a class="reference external" href="https://heiterbiswolkig.blogs.nde.ag/2024/09/06/pgs-not-deep-scrubbed-in-time/">Eugen Block 的博客</a> 。</p>
<p>见 <a class="reference external" href="https://tracker.ceph.com/issues/44959">Redmine tracker issue #44959</a> 。</p>
</section>
</section>
<section id="pg-slow-snap-trimming">
<h4>PG_SLOW_SNAP_TRIMMING<a class="headerlink" href="#pg-slow-snap-trimming" title="Permalink to this heading"></a></h4>
<p>至少有一个 PG 的快照修剪队列已超过配置的警告阈值。
此警报表明，近期删除了数量巨大的快照、
或者是 OSD 修剪快照的速度跟不上删除新快照的速度。</p>
<p>警告阈值由 <code class="xref std std-confval docutils literal notranslate"><span class="pre">mon_osd_snap_trim_queue_warn_on</span></code> 选项配置
（默认值： <code class="docutils literal notranslate"><span class="pre">32768</span></code> ）。</p>
<p>当 OSD 负载过高导致后台任务处理滞后，
或 OSD 内部元数据数据库严重碎片化而无法正常运作时，
可能触发此警报。
该警报也可能预示着 OSD 存在其他的性能问题。</p>
<p>快照修剪队列的准确大小可通过 <code class="docutils literal notranslate"><span class="pre">ceph</span> <span class="pre">pg</span> <span class="pre">ls</span> <span class="pre">-f</span> <span class="pre">json-detail</span></code> 命令中的
<code class="docutils literal notranslate"><span class="pre">snaptrimq_len</span></code> 字段获取。</p>
</section>
</section>
<section id="id13">
<h3>跨区域模式<a class="headerlink" href="#id13" title="Permalink to this heading"></a></h3>
<section id="incorrect-num-buckets-stretch-mode">
<h4>INCORRECT_NUM_BUCKETS_STRETCH_MODE<a class="headerlink" href="#incorrect-num-buckets-stretch-mode" title="Permalink to this heading"></a></h4>
<p>跨区域模式（ stretch mode ）目前仅支持两个隔离（ dividing ） CRUSH 桶，
桶内配置若干 OSD 。此警告表明，启用跨区域模式后，隔离的桶数量不是两个。
在修复此状况前，系统可能出现不可预测的故障以及监视器断言。</p>
<p>建议通过去除多余的隔离 CRUSH 桶或将隔离桶数量增至两个来修复此问题。
更多信息参阅 <a class="reference internal" href="../stretch-mode/#stretch-mode"><span class="std std-ref">Stretch Clusters</span></a> 。</p>
</section>
<section id="uneven-weights-stretch-mode">
<h4>UNEVEN_WEIGHTS_STRETCH_MODE<a class="headerlink" href="#uneven-weights-stretch-mode" title="Permalink to this heading"></a></h4>
<p>跨区域模式启用后，两个隔离 CRUSH 桶的权重必须相等。此警告表明，
启用跨区域模式后，两个隔离桶的权重不相等。虽然这不是紧要的致命错误，
但是当 Ceph 尝试在隔离桶之间切换时，可能会出现混乱。</p>
<p>我们建议您修复此问题，把两个隔离 CRUSH 桶的权重设置得相等即可。
具体就是确保各个隔离桶内 OSD 的总权重保持相同。详情见 <a class="reference internal" href="../stretch-mode/#stretch-mode"><span class="std std-ref">Stretch Clusters</span></a> 。</p>
</section>
<section id="nonexistent-mon-crush-loc-stretch-mode">
<h4>NONEXISTENT_MON_CRUSH_LOC_STRETCH_MODE<a class="headerlink" href="#nonexistent-mon-crush-loc-stretch-mode" title="Permalink to this heading"></a></h4>
<p>当启用了跨区域模式后，给监视器指定的 CRUSH 位置必须分布在隔离的 CRUSH 桶中。
唯一的例外是 tiebreaker 监视器，它必须位于隔离桶之外。</p>
<p>此警告表明，在跨区域模式下，至少有一个监视器的
CRUSH 位置不在任何一个隔离桶内。</p>
<p>建议您解决此问题，确保所有监视器（除了 tiebreaker 监视器以外）的
CRUSH 位置均位于隔离桶内。详情参阅：<a class="reference internal" href="../stretch-mode/#stretch-mode"><span class="std std-ref">Stretch Clusters</span></a> 。</p>
</section>
</section>
<section id="nvmeof">
<h3>NVMeoF 网关<a class="headerlink" href="#nvmeof" title="Permalink to this heading"></a></h3>
<section id="nvmeof-single-gateway">
<h4>NVMEOF_SINGLE_GATEWAY<a class="headerlink" href="#nvmeof-single-gateway" title="Permalink to this heading"></a></h4>
<p>有一个网关组只有一个网关。这种情况并不理想，
因为在一个组内只有一个网关时，无法实现高可用性（ HA ）。
这可能会导致 NVMeoF 网关的故障转移和故障恢复操作出现问题。</p>
<p>建议在一个组中配置多个 NVMeoF 网关。</p>
</section>
<section id="nvmeof-gateway-down">
<h4>NVMEOF_GATEWAY_DOWN<a class="headerlink" href="#nvmeof-gateway-down" title="Permalink to this heading"></a></h4>
<p>部分网关处于 <code class="docutils literal notranslate"><span class="pre">GW_UNAVAILABLE</span></code> 状态。如果 NVMeoF 守护进程崩溃，
这个守护进程的日志文件（位于 <code class="docutils literal notranslate"><span class="pre">/var/log/ceph/</span></code> 目录下）可能包含故障排除信息。</p>
</section>
<section id="nvmeof-gateway-deleting">
<h4>NVMEOF_GATEWAY_DELETING<a class="headerlink" href="#nvmeof-gateway-deleting" title="Permalink to this heading"></a></h4>
<p>部分网关当前处于 <code class="docutils literal notranslate"><span class="pre">GW_DELETING</span></code> 状态。它们将一直保持此状态，
直至网关负载均衡组下的所有命名空间都被转移到另一个负载均衡组 ID 之下。
这一过程由负载均衡进程自动完成。如果此警报持续存在很长时间，
说明该进程可能存在问题。</p>
</section>
</section>
<section id="id14">
<h3>杂项<a class="headerlink" href="#id14" title="Permalink to this heading"></a></h3>
<section id="recent-crash">
<h4>RECENT_CRASH<a class="headerlink" href="#recent-crash" title="Permalink to this heading"></a></h4>
<p>最近，至少有一个 Ceph 守护进程崩溃了，而且管理员尚未确认并存档这些崩溃事件。
此警报表明，可能存在软件错误、
硬件问题（例如，即将发生故障的磁盘）或其他问题。</p>
<p>要罗列最近的崩溃事件，执行下列命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1">ceph<span class="w"> </span>crash<span class="w"> </span>ls-new</span>
</pre></div></div><p>要检查某一次崩溃的信息，执行下列命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1">ceph<span class="w"> </span>crash<span class="w"> </span>info<span class="w"> </span>&lt;crash-id&gt;</span>
</pre></div></div><p>要把这个警告消音，你可以归档此次崩溃（可能得在管理员检查过此崩溃之后），
执行下列命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1">ceph<span class="w"> </span>crash<span class="w"> </span>archive<span class="w"> </span>&lt;crash-id&gt;</span>
</pre></div></div><p>类似地，要归档近期的所有崩溃，执行下列命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1">ceph<span class="w"> </span>crash<span class="w"> </span>archive-all</span>
</pre></div></div><p>归档起来的崩溃仍然能用 <code class="docutils literal notranslate"><span class="pre">ceph</span> <span class="pre">crash</span> <span class="pre">ls</span></code> 命令看到，
但是用 <code class="docutils literal notranslate"><span class="pre">ceph</span> <span class="pre">crash</span> <span class="pre">ls-new</span></code> 命令看不到。</p>
<p>最近这个时间段有多长由选项 <code class="xref std std-confval docutils literal notranslate"><span class="pre">mgr/crash/warn_recent_interval</span></code>
（默认值：两周）定义。</p>
<p>要完全禁用此警告，执行下列命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1">ceph<span class="w"> </span>config<span class="w"> </span><span class="nb">set</span><span class="w"> </span>mgr/crash/warn_recent_interval<span class="w"> </span><span class="m">0</span></span>
</pre></div></div></section>
<section id="recent-mgr-module-crash">
<h4>RECENT_MGR_MODULE_CRASH<a class="headerlink" href="#recent-mgr-module-crash" title="Permalink to this heading"></a></h4>
<p>最近，至少有一个管理器模块崩溃过，而且管理员尚未确认并存档这些崩溃。
此警报通常表明，在管理器（ <code class="docutils literal notranslate"><span class="pre">ceph-mgr</span></code> ）守护进程中运行的某个软件模块存在软件缺陷。
出现问题的模块可能会因此被禁用，
但其他模块不受影响，仍能按预期运行。</p>
<p>与 <a class="reference internal" href="#recent-crash">RECENT_CRASH</a> 健康检查一样，可以调查某个特定的崩溃，
执行下列命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1">ceph<span class="w"> </span>crash<span class="w"> </span>info<span class="w"> </span>&lt;crash-id&gt;</span>
</pre></div></div><p>要把这个警告消音，你可以归档此次崩溃（可能得在管理员检查过此崩溃之后），
执行下列命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1">ceph<span class="w"> </span>crash<span class="w"> </span>archive<span class="w"> </span>&lt;crash-id&gt;</span>
</pre></div></div><p>类似地，要归档近期的所有崩溃，执行下列命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1">ceph<span class="w"> </span>crash<span class="w"> </span>archive-all</span>
</pre></div></div><p>归档起来的崩溃仍然能用 <code class="docutils literal notranslate"><span class="pre">ceph</span> <span class="pre">crash</span> <span class="pre">ls</span></code> 命令看到，
但是用 <code class="docutils literal notranslate"><span class="pre">ceph</span> <span class="pre">crash</span> <span class="pre">ls-new</span></code> 命令看不到。</p>
<p>最近这个时间段有多长由选项 <code class="xref std std-confval docutils literal notranslate"><span class="pre">mgr/crash/warn_recent_interval</span></code>
（默认值：两周）定义。</p>
<p>要完全禁用此警告，执行下列命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1">ceph<span class="w"> </span>config<span class="w"> </span><span class="nb">set</span><span class="w"> </span>mgr/crash/warn_recent_interval<span class="w"> </span><span class="m">0</span></span>
</pre></div></div></section>
<section id="telemetry-changed">
<h4>TELEMETRY_CHANGED<a class="headerlink" href="#telemetry-changed" title="Permalink to this heading"></a></h4>
<p>Telemetry （遥测）功能已经启用，但同时由于 telemetry 报告的内容被更改了，
所以 telemetry 报告不会发出去。</p>
<p>Ceph 开发人员偶尔会修订 telemetry 功能，以纳入新的有用信息，
或去除后来发现无用或敏感的信息。
如果报告中包含了任意一点新信息，
Ceph 都会要求管理员重新启用 telemetry 功能。
这一要求确保管理员有机会（重新）审查将要共享的信息。</p>
<p>要审查 telemetry 报告的内容，执行下列命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1">ceph<span class="w"> </span>telemetry<span class="w"> </span>show</span>
</pre></div></div><p>注意， telemetry 报告包含多个通道，这些通道可以独立启用或禁用。
详情参阅 <a class="reference internal" href="../../../mgr/telemetry/#telemetry"><span class="std std-ref">Telemetry Module</span></a> 。</p>
<p>要重新启用 telemetry （并消除这条警报），执行下列命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1">ceph<span class="w"> </span>telemetry<span class="w"> </span>on</span>
</pre></div></div><p>要禁用 telemetry （并消除这条警报），执行下列命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1">ceph<span class="w"> </span>telemetry<span class="w"> </span>off</span>
</pre></div></div></section>
<section id="auth-bad-caps">
<h4>AUTH_BAD_CAPS<a class="headerlink" href="#auth-bad-caps" title="Permalink to this heading"></a></h4>
<p>至少有一个授权用户具有监视器无法解析的能力。通常，
此警报表示有一个或多个守护进程正在用未被授权执行任何操作的用户进行身份验证。</p>
<p>此警报最有可能在升级后触发，如果
（1）这些能力是在旧版本的 Ceph 中设置的，
而旧版本 Ceph 没有正确验证这些功能的语法，
或者（2）能力的语法变了。</p>
<p>要删除可疑用户，执行下列命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1">ceph<span class="w"> </span>auth<span class="w"> </span>rm<span class="w"> </span>&lt;entity-name&gt;</span>
</pre></div></div><p>（这解决了健康检查的问题，但同时也使得客户端无法以被删除用户的身份进行身份验证。）</p>
<p>另外，要更新用户的能力，
执行下列命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1">ceph<span class="w"> </span>auth<span class="w"> </span>&lt;entity-name&gt;<span class="w"> </span>&lt;daemon-type&gt;<span class="w"> </span>&lt;caps&gt;<span class="w"> </span><span class="o">[</span>&lt;daemon-type&gt;<span class="w"> </span>&lt;caps&gt;<span class="w"> </span>...<span class="o">]</span></span>
</pre></div></div><p>关于认证能力的详情，见 <a class="reference internal" href="../user-management/#user-management"><span class="std std-ref">用户管理</span></a> 。</p>
</section>
<section id="osd-no-down-out-interval">
<h4>OSD_NO_DOWN_OUT_INTERVAL<a class="headerlink" href="#osd-no-down-out-interval" title="Permalink to this heading"></a></h4>
<p><a class="reference internal" href="../../configuration/mon-osd-interaction/#confval-mon_osd_down_out_interval"><code class="xref std std-confval docutils literal notranslate"><span class="pre">mon_osd_down_out_interval</span></code></a> 选项设置成了零，
这意味着当 OSD 发生故障时，系统不会自动执行任何修复或恢复操作。
相反，管理员或外部编排器必须手动将状态为 <code class="docutils literal notranslate"><span class="pre">down</span></code> 的 OSD 标记为 <code class="docutils literal notranslate"><span class="pre">out</span></code>
（用命令 <code class="docutils literal notranslate"><span class="pre">ceph</span> <span class="pre">osd</span> <span class="pre">out</span> <span class="pre">&lt;osd-id&gt;</span></code> ），以触发系统恢复。</p>
<p>这个选项通常设置成 5 或 10 分钟 - 足够一台主机更换电源或重启。</p>
<p>要消除此警报，可以把 <a class="reference internal" href="../../configuration/mon-config-ref/#confval-mon_warn_on_osd_down_out_interval_zero"><code class="xref std std-confval docutils literal notranslate"><span class="pre">mon_warn_on_osd_down_out_interval_zero</span></code></a>
设置成 <code class="docutils literal notranslate"><span class="pre">false</span></code> ，执行下列命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1">ceph<span class="w"> </span>config<span class="w"> </span>global<span class="w"> </span>mon<span class="w"> </span>mon_warn_on_osd_down_out_interval_zero<span class="w"> </span><span class="nb">false</span></span>
</pre></div></div></section>
<section id="dashboard-debug">
<h4>DASHBOARD_DEBUG<a class="headerlink" href="#dashboard-debug" title="Permalink to this heading"></a></h4>
<p>打开了 Dashboard 调试模式。这意味着，如果在处理一个 REST API 请求时出错了，
HTTP 错误响应会包含 Python 的追溯信息（ traceback ）。
这个行为在生产环境下应该禁用，因为这样的回溯信息可能包含并暴露敏感信息。</p>
<p>要禁用调试模式，执行下列命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1">ceph<span class="w"> </span>dashboard<span class="w"> </span>debug<span class="w"> </span>disable</span>
</pre></div></div></section>
<section id="blaum-roth-w-is-not-prime">
<h4>BLAUM_ROTH_W_IS_NOT_PRIME<a class="headerlink" href="#blaum-roth-w-is-not-prime" title="Permalink to this heading"></a></h4>
<p>一个纠删码存储池正在用 <code class="docutils literal notranslate"><span class="pre">blaum_roth</span></code> 技术，且 <code class="docutils literal notranslate"><span class="pre">w</span> <span class="pre">+</span> <span class="pre">1</span></code> 不是素数。
如果这个存储池需要回填或恢复，可能会导致数据损坏。</p>
<p>要罗列出纠删码配置，执行下列命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt2">ceph<span class="w"> </span>osd<span class="w"> </span>erasure-code-profile<span class="w"> </span>ls</span>
</pre></div></div><p>然后，查看一份指定配置的 <code class="docutils literal notranslate"><span class="pre">w</span></code> 值，执行下列命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt2">ceph<span class="w"> </span>osd<span class="w"> </span>erasure-code-profile<span class="w"> </span>get<span class="w"> </span>&lt;name<span class="w"> </span>of<span class="w"> </span>profile&gt;</span>
</pre></div></div><p>理想的解决方案是用正确的 <code class="docutils literal notranslate"><span class="pre">w</span></code> 值新建一个存储池，并复制所有对象。
然后，在数据损坏发生前删掉旧的存储池。</p>
</section>
</section>
</section>
</section>



<div id="support-the-ceph-foundation" class="admonition note">
  <p class="first admonition-title">Brought to you by the Ceph Foundation</p>
  <p class="last">The Ceph Documentation is a community resource funded and hosted by the non-profit <a href="https://ceph.io/en/foundation/">Ceph Foundation</a>. If you would like to support this and our other efforts, please consider <a href="https://ceph.io/en/foundation/join/">joining now</a>.</p>
</div>


           </div>
           
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="../operating/" class="btn btn-neutral float-left" title="操纵集群" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="../monitoring/" class="btn btn-neutral float-right" title="监控集群" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2016, Ceph authors and contributors. Licensed under Creative Commons Attribution Share Alike 3.0 (CC-BY-SA-3.0).</p>
  </div>

   

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>